---
title: CLI Reference
description: Complete guide to all HORUS commands
order: 40
---

# CLI Reference

The `horus` command gives you everything you need to build, run, and manage your applications. This page covers all 10 commands.

## Quick Reference

```bash
horus init                 # Initialize workspace in current directory
horus new <name>           # Create a new project
horus run [file]           # Build and run your app
horus check                # Validate dependencies and environment
horus monitor [port]     # Monitor your system
horus sim2d                # Launch 2D simulator
horus sim3d                # Launch 3D simulator
horus pkg <command>        # Manage packages (install, publish, etc.)
horus env <command>        # Save/restore environments
horus auth <command>       # Login to registry
```

---

## `horus init` - Initialize Workspace

**What it does**: Initializes a HORUS workspace in the current directory, creating the necessary configuration files.

**Why it's useful**: Quickly set up an existing directory as a HORUS project without creating new files from templates.

### Basic Usage

```bash
# Initialize in current directory (uses directory name)
horus init

# Initialize with custom name
horus init --name my_robot
```

### All Options

```bash
horus init [OPTIONS]

Options:
  -n, --name <NAME>    Workspace name (defaults to directory name)
```

### Examples

**Initialize existing code as HORUS project**:
```bash
cd ~/my-robot-code
horus init
# Creates horus.yaml with project configuration
```

**Initialize with specific name**:
```bash
horus init --name sensor_array
```

### What Gets Created

Running `horus init` creates:
- `horus.yaml` - Project manifest with name and version

This is useful when you have existing code and want to add HORUS support, or when setting up a workspace that will contain multiple HORUS projects.

---

## `horus new` - Create Projects

**What it does**: Creates a new HORUS project with all the boilerplate set up for you.

**Why it's useful**: Minimal configuration required. Select a language and begin development.

### Basic Usage

```bash
# Interactive mode (asks you questions)
horus new my_project

# Rust with node! macro (recommended for reduced boilerplate)
horus new my_project --macro

# Python project
horus new my_project --python
```

### All Options

```bash
horus new <NAME> [OPTIONS]

Options:
  -m, --macro              Rust with node! macro (less boilerplate)
  -r, --rust               Plain Rust project
  -p, --python             Python project
  -o, --output <PATH>      Where to create it (default: current directory)
```

### Examples

**Start with Rust + macros** (easiest):
```bash
horus new temperature_monitor --macro
cd temperature_monitor
horus run
```

**Python for prototyping**:
```bash
horus new sensor_test --python
cd sensor_test
python main.py
```

**Put it somewhere specific**:
```bash
horus new robot_controller --output ~/projects/robots
```

---

## `horus run` - Build and Run

**What it does**: Compiles your code and runs it. Handles all the build tools for you.

**Why it's useful**: One command works for Rust and Python. For Rust, it auto-generates `Cargo.toml` from `horus.yaml` and uses Cargo for compilation. For Python, it handles the appropriate tooling.

### Basic Usage

```bash
# Run current directory (finds main.rs or main.py)
horus run

# Run specific file
horus run src/controller.rs

# Run optimized (release mode)
horus run --release
```

### All Options

```bash
horus run [FILE] [OPTIONS] [-- ARGS]

Options:
  -r, --release            Optimize for speed (recommended for benchmarks)
  -b, --build-only         Compile without running
  -c, --clean              Remove cached build artifacts and dependencies
                           (Use after updating HORUS or when compilation fails)
  -- <ARGS>                Arguments for your program
```

### Why --release Matters

Debug builds have significantly higher overhead than release builds due to runtime checks and lack of optimizations.

**Debug mode** (default): Fast compilation, slower execution
- Use case: Development iteration
- Typical tick time: 60-200μs
- Includes overflow checks, bounds checking, assertions

**Release mode** (`--release`): Slower compilation, optimized execution
- Use case: Performance testing, benchmarks, production deployment
- Typical tick time: 1-3μs
- Full compiler optimizations enabled

**Common Mistake:**
```bash
horus run  # Debug mode
# You see: [IPC: 1862ns | Tick: 87μs] - Looks slow!

horus run --release  # Release mode
# You see: [IPC: 947ns | Tick: 2μs] - Actually fast!
```

**The tick time difference is dramatic:**
- Debug: 60-200μs per tick (too slow for real-time control)
- Release: 1-3μs per tick (production-ready performance)

**Rule of thumb:** Always use `--release` when:
- Measuring performance
- Running benchmarks
- Testing real-time control loops
- Deploying to production
- Wondering "why is HORUS slow?"

### Why --clean Matters

The `--clean` flag removes the `.horus/target/` directory, which contains cached build artifacts and dependencies.

**When to use `--clean`:**

1. **After updating HORUS** - Most common use case
   ```bash
   # You updated horus CLI to a new version
   horus run --clean
   ```
   This fixes version mismatch errors like:
   ```
   error: the package `horus` depends on `horus_core 0.1.0`,
   but `horus_core 0.1.3` is installed
   ```

2. **Compilation fails mysteriously**
   ```bash
   horus run --clean
   # Sometimes cached state gets corrupted
   ```

3. **Dependencies changed**
   ```bash
   # You modified horus.yaml dependencies
   horus run --clean
   ```

**What it does:**
- Removes `.horus/target/` (build artifacts)
- Removes `.horus/Cargo.lock` (dependency lock file)
- Forces fresh dependency resolution
- Next build rebuilds everything from scratch

**Trade-off:**
- First build after `--clean` is slower (5-30 seconds)
- Subsequent builds are fast again (incremental compilation)

**Note:** The `--clean` flag only affects the current project's `.horus/` directory, not the global `~/.horus/` cache.

### Examples

**Daily development**:
```bash
horus run
# Fast iteration, slower execution
```

**Testing performance**:
```bash
horus run --release
# See real speed
```

**Build for CI without running**:
```bash
horus run --build-only --release
```

**Fresh build** (when things act weird or after updating HORUS):
```bash
horus run --clean --release
```

**After updating HORUS CLI** (fixes version mismatch errors):
```bash
# Clean removes cached dependencies from .horus/target/
horus run --clean
```

**Pass arguments to your program**:
```bash
horus run -- --config robot.yaml --verbose
```

### Important: Single-File Projects Only

`horus run` is designed for **single-file HORUS projects** (main.rs or main.py). It creates a temporary workspace in `.horus/` and automatically handles dependencies.

**What works with `horus run`:**
- Single main.rs with all nodes defined in one file
- Simple Python scripts (main.py)

**What doesn't work:**
- Multi-crate Cargo workspaces
- Projects with multiple Cargo.toml files
- Complex module structures with separate crate directories

**For multi-crate projects**, use `cargo` directly:
```bash
cd your_multi_crate_project
cargo build --release
cargo run --release
```

**Example of a proper single-file structure:**
```rust
// main.rs - everything in one file
use horus::prelude::*;

struct SensorNode { /* ... */ }
impl Node for SensorNode { /* ... */ }

struct ControlNode { /* ... */ }
impl Node for ControlNode { /* ... */ }

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();
    scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));
    scheduler.add(Box::new(ControlNode::new()?), 1, Some(true));
    scheduler.run()
}
```

### Concurrent Multi-Process Execution

HORUS supports running multiple node files concurrently as separate processes using **glob patterns**. This is ideal for distributed robotics systems where nodes need to run independently.

**Basic Usage:**
```bash
horus run "nodes/*.py"          # Run all Python nodes concurrently
horus run "src/*.rs"            # Run all Rust nodes concurrently
```

**How it works:**
1. **Phase 1 (Build)**: Builds all files sequentially, respecting Cargo's file lock
2. **Phase 2 (Execute)**: Spawns all processes concurrently with their own schedulers
3. Each process communicates via HORUS shared memory IPC

**Features:**
- -**Color-coded output**: Each node is prefixed with `[node_name]` in a unique color
- -**Graceful shutdown**: Ctrl+C cleanly terminates all processes
- -**Multi-language**: Works with Rust and Python
- -**Automatic detection**: No flags needed, just use glob patterns

**Example output:**
```bash
$ horus run "nodes/*.py"
 Executing 3 files concurrently:
  1. nodes/sensor.py (python)
  2. nodes/controller.py (python)
  3. nodes/logger.py (python)

 Phase 1: Building all files...
 Phase 2: Starting all processes...
   Started [sensor]
   Started [controller]
   Started [logger]

 All processes running. Press Ctrl+C to stop.

[sensor] Sensor reading: 25.3°C
[controller] Motor speed: 45%
[logger] System operational
[sensor] Sensor reading: 26.1°C
[controller] Motor speed: 50%
[logger] System operational
```

**When to use concurrent execution:**
- Multi-node systems where each node is in a separate file
- Distributed control architectures (similar to ROS nodes)
- Testing multiple nodes simultaneously
- Microservices-style robotics architectures

**When to use single-process execution:**
- All nodes in one file (typical for simple projects)
- Projects requiring deterministic scheduling across all nodes
- Maximum performance with minimal overhead

**Important:** Each process runs its own scheduler. Nodes communicate through HORUS shared memory topics (`/dev/shm/horus/`), not direct function calls.

---

## `horus check` - Validate Environment

**What it does**: Validates your HORUS installation, dependencies, and environment configuration.

**Why it's useful**: Quickly diagnose issues with your setup before running into cryptic errors. Ensures all dependencies are properly installed and versions are compatible.

### Basic Usage

```bash
# Check current project
horus check

# Check specific package
horus check my-package
```

### What It Checks

The `horus check` command validates:
- **HORUS installation** - Core framework is properly installed
- **Dependencies** - All required packages are available
- **Package versions** - Version compatibility with `horus.yaml`
- **Environment** - Cargo, Python, and system tools are configured
- **Shared memory** - `/dev/shm` is accessible and writable

### Example Output

```bash
$ horus check
 HORUS framework installed (v0.1.0)
 Cargo toolchain found (1.70.0)
 Python bindings available (3.11)
 Shared memory accessible (/dev/shm)
 All dependencies satisfied

 Environment is ready!
```

**When validation fails**:
```bash
$ horus check
 HORUS framework installed (v0.1.0)
[FAIL] Missing dependency: horus-vision (required by horus.yaml)
[FAIL] Shared memory not writable (/dev/shm)

[WARNING] Fix these issues and run 'horus check' again
```

### Examples

**Before starting development**:
```bash
horus check
# Ensure environment is ready
```

**After installing packages**:
```bash
horus pkg install sensor-drivers
horus check
# Verify installation succeeded
```

**Troubleshooting build issues**:
```bash
horus check
# Identify missing dependencies
```

**CI/CD validation**:
```bash
#!/bin/bash
if ! horus check; then
  echo "Environment validation failed"
  exit 1
fi
horus run --release
```

---

## `horus sim2d` - Launch 2D Simulator

**What it does**: Launches the HORUS 2D simulator for testing robot behavior in a virtual environment.

**Why it's useful**: Test your algorithms without hardware. Validate behavior before deploying to real robots. Perfect for development and learning.

### Basic Usage

```bash
# Launch default simulation
horus sim2d

# Launch with world configuration
horus sim2d --world warehouse.yaml

# Headless mode (for testing)
horus sim2d --headless
```

### All Options

```bash
horus sim2d [OPTIONS]

Options:
  --headless                 Run without GUI (for CI/CD)
  --world <FILE>             World configuration file
  --world-image <FILE>       World image file (PNG, JPG, PGM) - occupancy grid
  --resolution <FLOAT>       Resolution in meters per pixel for world image
  --threshold <0-255>        Obstacle threshold (darker = obstacle)
  --robot <FILE>             Robot configuration file
  --topic <PREFIX>           HORUS topic prefix (default: /robot)
  --name <NAME>              Robot name for logging (default: robot)
```

### What You Get

The simulator provides:
- **2D physics** - Realistic robot movement and collisions
- **Sensor simulation** - Virtual LiDAR, odometry, IMU
- **Visual debugging** - See robot state and sensor readings
- **Occupancy grid support** - Load world images directly
- **HORUS integration** - Nodes communicate normally via shared memory

### Examples

**Test navigation algorithm**:
```bash
# Terminal 1: Launch simulator with world
horus sim2d --world maze.yaml

# Terminal 2: Run your navigation code
horus run navigation.rs --release

# Terminal 3: Monitor
horus monitor
```

**Headless testing (CI/CD)**:
```bash
horus sim2d --headless &
SIM_PID=$!
horus run test_behavior.rs --release
kill $SIM_PID
```

**Load occupancy grid image**:
```bash
# Load a PGM/PNG map as world
horus sim2d --world-image map.pgm --resolution 0.05 --threshold 128
```

### Integration with Your Code

Your HORUS nodes work unchanged in simulation:

```rust
// Same code works in sim and on real robot!
use horus::prelude::*;

struct RobotController {
    cmd_pub: Hub<CmdVel>,
    lidar_sub: Hub<LaserScan>,
}

impl RobotController {
    fn new() -> Result<Self> {
        Ok(Self {
            cmd_pub: Hub::new("cmd_vel")?,
            lidar_sub: Hub::new("scan")?,
        })
    }
}

impl Node for RobotController {
    fn name(&self) -> &'static str {
        "RobotController"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Read simulated LiDAR
        if let Some(scan) = self.lidar_sub.recv(&mut ctx) {
            // Send commands to simulated robot
            let cmd = calculate_motion(&scan);
            self.cmd_pub.send(cmd, &mut ctx).ok();
        }
    }
}
```

**Simulator vs Reality**: The same HORUS topics (`cmd_vel`, `scan`, `odom`, etc.) work in both. No code changes needed!

---

## `horus sim3d` - Launch 3D Simulator

**What it does**: Launches the HORUS 3D simulator with full physics, URDF robot support, and advanced sensor simulation.

**Why it's useful**: Realistic 3D testing environment for complex robots, manipulators, and scenarios requiring depth perception or 3D physics.

### Basic Usage

```bash
# Launch default 3D simulation
horus sim3d

# Launch with URDF robot
horus sim3d --robot turtlebot3.urdf

# Headless mode for RL training
horus sim3d --headless --seed 42
```

### All Options

```bash
horus sim3d [OPTIONS]

Options:
  --headless         Run without GUI (for RL training, CI/CD)
  --seed <U64>       Random seed for deterministic simulation
  --robot <FILE>     Robot URDF file to load
  --world <FILE>     World/scene configuration file
```

### Features

The 3D simulator provides:
- **Full 3D physics** - Rapier3D physics engine with realistic dynamics
- **URDF support** - Load standard robot description files
- **3D sensors** - LiDAR 3D, RGB-D cameras, IMU
- **Deterministic mode** - Use `--seed` for reproducible simulations
- **RL training ready** - Headless mode for high-speed training

### Examples

**Visual simulation with robot**:
```bash
horus sim3d --robot my_robot.urdf --world warehouse.yaml
```

**Deterministic RL training**:
```bash
# Same seed = same simulation
horus sim3d --headless --seed 12345
```

**Test with custom world**:
```bash
horus sim3d --world obstacle_course.yaml --robot quadruped.urdf
```

See [Simulation Guide](/development/simulation) for advanced features, custom scenarios, and RL integration.

---

## `horus monitor` - Monitor Everything

**What it does**: Opens a visual monitor showing all your running nodes, messages, and performance.

**Why it's useful**: Debug problems visually. See message flow in real-time. Monitor performance.

### Basic Usage

```bash
# Web monitor (opens in browser)
horus monitor

# Different port
horus monitor 8080

# Text-based (for SSH)
horus monitor --tui

# Reset monitor password before starting
horus monitor --reset-password
```

### What You See

The monitor shows:
- **All running nodes** - Names, status, tick rates
- **Message flow** - What's talking to what
- **Performance** - CPU, memory, latency per node
- **Topics** - All active communication channels
- **Graph view** - Visual network of your system

### Examples

**Start monitoring** (in a second terminal):
```bash
# Terminal 1: Run your app
horus run --release

# Terminal 2: Watch it
horus monitor
```

**Access from your phone**:
```bash
horus monitor
# Visit http://your-computer-ip:3000 from phone
```

**Monitor over SSH**:
```bash
ssh robot@192.168.1.100
horus monitor --tui
```

See [Monitor Guide](/development/monitor) for detailed features.

---

## `horus pkg` - Package Management

**What it does**: Install and manage reusable components.

**Why it's useful**: Don't reinvent the wheel. Use components others have built and tested.

### Commands

```bash
# Install a package
horus pkg install <package>

# Remove a package
horus pkg remove <package>

# List packages
horus pkg list

# Publish current package to registry
horus pkg publish

# Unpublish a package from registry
horus pkg unpublish <package> <version>
```

### Examples

**Install a package**:
```bash
horus pkg install pid-controller
```

**Install specific version**:
```bash
horus pkg install pid-controller --ver 1.2.0
```

**Install globally** (share across projects):
```bash
horus pkg install common-utils --global
```

**See what's installed**:
```bash
horus pkg list
```

**Search for packages**:
```bash
horus pkg list sensor
```

**Remove a package**:
```bash
horus pkg remove pid-controller
```

**Publish your package to registry**:
```bash
# First login
horus auth login

# Then publish from your project directory
horus pkg publish
```

**Unpublish from registry** (irreversible!):
```bash
horus pkg unpublish my-package 1.0.0
```

---

## `horus env` - Environment Management

**What it does**: Save and restore your exact setup (all package versions).

**Why it's useful**: Share your setup with teammates. Deploy the same version to production. Time-travel to old configurations.

### Commands

```bash
# Save current environment
horus env freeze

# Load saved environment
horus env restore <file>
```

### Examples

**Save your setup**:
```bash
horus env freeze
# Creates horus-freeze.yaml
```

**Load teammate's setup**:
```bash
horus env restore teammate-setup.yaml
```

**Deploy exact production environment**:
```bash
# On production machine
horus env restore production.yaml
```

---

## `horus auth` - Login to Registry

**What it does**: Authenticate so you can publish packages.

**Why it's useful**: Secure access to the package registry.

### Commands

```bash
# Login with GitHub
horus auth login

# Generate API key (for CI/CD)
horus auth generate-key

# Check who you are
horus auth whoami

# Logout
horus auth logout
```

### Examples

**First time setup**:
```bash
horus auth login
# Opens browser for GitHub login
```

**Check you're logged in**:
```bash
horus auth whoami
```

**Generate API key for CI/CD**:
```bash
horus auth generate-key --name github-actions --environment ci-cd
# Save the generated key in your CI secrets
```

**Logout**:
```bash
horus auth logout
```

---

## Common Workflows

### First Time Using HORUS

```bash
# Create a project
horus new my_first_app --macro
cd my_first_app

# Run it
horus run --release

# Monitor it (new terminal)
horus monitor
```

### Daily Development

```bash
# Make changes to code
vim src/main.rs

# Test quickly
horus run

# Test for real
horus run --release
```

### Deploy to Production

```bash
# Clean build
horus run --clean --release

# Save the environment
horus env freeze --output production.yaml

# Run in production mode
horus run --release
```

### Share Your Work

```bash
# Login once
horus auth login

# Publish
horus pkg publish

# Others can now:
horus pkg install your-package-name
```

---

## Troubleshooting

### "command not found: horus"

Add cargo to your PATH:

```bash
export PATH="$HOME/.cargo/bin:$PATH"
echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc
```

### "Port already in use"

```bash
# Use different port
horus monitor 3001

# Or kill the old process
lsof -ti:3000 | xargs kill -9
```

### Build is slow

First build is always slow (5-10 min). After that it's fast (seconds).

Use `--release` only when you need speed, not during development.

### "Failed to create Hub"

Topic name conflict. Try a unique name or clean up stale shared memory.

**Note**: HORUS automatically cleans up shared memory after each run using session isolation. This error usually means a previous run crashed.

```bash
# Clean all HORUS shared memory (if needed after crashes)
rm -rf /dev/shm/horus/
```

---

## Environment Variables

Optional configuration:

```bash
# Custom registry (for companies)
export HORUS_REGISTRY_URL=https://your-company-registry.com

# Debug mode (see what's happening)
export RUST_LOG=debug
horus run

# CI/CD authentication
export HORUS_API_KEY=your-key-here
```

---

## Utility Scripts

Beyond the `horus` CLI, the repository includes helpful scripts:

```bash
./install.sh             # Install or update HORUS
./verify.sh              # Check installation health
```

See **[Troubleshooting & Maintenance](/troubleshooting)** for complete details.

---

## Next Steps

Now that you know the commands:

1. **[Quick Start](/getting-started/quick-start)** - Build your first app
2. **[node! Macro](/concepts/node-macro)** - Write less code
3. **[Monitor Guide](/development/monitor)** - Master monitoring
4. **[Examples](/rust/examples/basic-examples)** - See real applications

**Having issues?** Check the **[Troubleshooting Guide](/troubleshooting)** for solutions to common problems.
