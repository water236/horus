---
title: Library Reference
description: Complete reference for HORUS standard library - messages, tools, and APIs
order: 42
---

# Library Reference

The HORUS Standard Library (`horus_library`) provides ready-to-use message types, development tools, and utilities for robotics applications. Use these components to accelerate development and ensure compatibility across projects.

## Overview

The library includes:

- **Standard Messages** - Memory-safe message types for common robotics data
- **Built-in Nodes** - Production-ready nodes for sensors, actuators, and control (see [Built-in Nodes/Drivers](/rust/library/built-in-nodes))
- **Example Applications** - Complete multi-node demonstrations
- **Development Tools** - Simulators and testing utilities

**Installation:**
```toml
[dependencies]
horus_library = "0.1"
```

**Import:**
```rust
use horus::prelude::*;
// Or specific items:
use horus_library::{CmdVel, LaserScan, ImuNode};
```

---

## Standard Messages

All messages are designed for shared memory safety with fixed-size fields.

### Motion & Control

#### `CmdVel`
Velocity command for mobile robots.

```rust
pub struct CmdVel {
    pub linear: f64,   // Linear velocity (m/s)
    pub angular: f64,  // Angular velocity (rad/s)
}
```

**Size:** 16 bytes
**Latency:** 248ns (Link) / ~500ns (Hub)

**Usage:**
```rust
let cmd = CmdVel {
    linear: 1.5,   // Move forward at 1.5 m/s
    angular: 0.5,  // Turn at 0.5 rad/s
};
cmd_hub.send(cmd, &mut ctx).ok();
```

#### `Twist`
Full 3D velocity (position and orientation).

```rust
pub struct Twist {
    pub linear: Vector3,   // Linear velocity (m/s)
    pub angular: Vector3,  // Angular velocity (rad/s)
}

pub struct Vector3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
```

**Size:** 48 bytes
**Use for:** Drones, robotic arms, 3D movement

#### `PIDState`
PID controller state.

```rust
pub struct PIDState {
    pub kp: f64,           // Proportional gain
    pub ki: f64,           // Integral gain
    pub kd: f64,           // Derivative gain
    pub setpoint: f64,     // Target value
    pub error: f64,        // Current error
    pub integral: f64,     // Accumulated integral
    pub derivative: f64,   // Error derivative
    pub output: f64,       // Control output
}
```

**Size:** 64 bytes

### Sensors

#### `LaserScan`
2D LIDAR scan data.

```rust
pub struct LaserScan {
    pub ranges: [f32; 360],        // Distance readings (m)
    pub angle_min: f32,            // Start angle (rad)
    pub angle_max: f32,            // End angle (rad)
    pub angle_increment: f32,      // Angular resolution
    pub time_increment: f32,       // Time between readings
    pub scan_time: f32,            // Total scan time
    pub range_min: f32,            // Minimum valid range
    pub range_max: f32,            // Maximum valid range
}
```

**Size:** 1.5 KB
**Latency:** ~900ns (Link) / ~2.2µs (Hub)

**Usage:**
```rust
if let Some(scan) = lidar_hub.recv(&mut ctx) {
    for (i, range) in scan.ranges.iter().enumerate() {
        if *range < 0.5 {  // Obstacle within 0.5m
            ctx.log_warning("Obstacle detected!");
        }
    }
}
```

#### `IMU`
Inertial Measurement Unit data.

```rust
pub struct IMU {
    pub orientation: Quaternion,        // Orientation
    pub angular_velocity: Vector3,      // Gyroscope (rad/s)
    pub linear_acceleration: Vector3,   // Accelerometer (m/s²)
    pub timestamp: u64,                 // Microseconds
}

pub struct Quaternion {
    pub w: f64,
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
```

**Size:** 304 bytes
**Latency:** ~400ns (Link) / ~940ns (Hub)

#### `Image`
Camera image data.

```rust
pub struct Image {
    pub width: u32,
    pub height: u32,
    pub encoding: ImageEncoding,
    pub data: [u8; MAX_IMAGE_SIZE],  // Fixed-size buffer
}

pub enum ImageEncoding {
    RGB8,    // 8-bit RGB
    BGR8,    // 8-bit BGR
    MONO8,   // 8-bit grayscale
    JPEG,    // JPEG compressed
}
```

**Note:** For high-resolution images, consider using zero-copy `loan()` API.

### Navigation

#### `Odometry`
Robot position and velocity estimate.

```rust
pub struct Odometry {
    pub pose: Pose,      // Position estimate
    pub twist: Twist,    // Velocity estimate
    pub timestamp: u64,
}

pub struct Pose {
    pub position: Vector3,
    pub orientation: Quaternion,
}
```

**Size:** 736 bytes
**Latency:** 650ns

#### `Path`
Navigation path.

```rust
pub struct Path {
    pub waypoints: [Pose; MAX_WAYPOINTS],
    pub length: usize,
    pub timestamp: u64,
}
```

**Use for:** Path planning, trajectory following

### Input

#### `KeyboardInput`
Keyboard events.

```rust
pub struct KeyboardInput {
    pub key: KeyCode,
    pub event: KeyEvent,
    pub modifiers: KeyModifiers,
}

pub enum KeyCode {
    Up, Down, Left, Right,
    W, A, S, D,
    Space, Enter, Esc,
    // ... full keyboard
}

pub enum KeyEvent {
    Press,
    Release,
}
```

**Size:** 16 bytes

**Usage:**
```rust
if let Some(input) = keyboard_hub.recv(&mut ctx) {
    match (input.key, input.event) {
        (KeyCode::W, KeyEvent::Press) => move_forward(),
        (KeyCode::Space, KeyEvent::Press) => stop(),
        _ => {}
    }
}
```

#### `JoystickInput`
Game controller input.

```rust
pub struct JoystickInput {
    pub axes: [f32; 8],      // Analog axes [-1.0, 1.0]
    pub buttons: [bool; 16], // Button states
    pub timestamp: u64,
}
```

**Typical mapping:**
- `axes[0]` - Left stick X
- `axes[1]` - Left stick Y
- `axes[2]` - Right stick X
- `axes[3]` - Right stick Y
- `buttons[0]` - A button
- `buttons[1]` - B button

### Diagnostics

#### `Health`
Node health status.

```rust
pub struct Health {
    pub status: HealthStatus,
    pub cpu_percent: f32,
    pub memory_mb: u64,
    pub error_count: u32,
    pub warning_count: u32,
    pub message: [u8; 256],  // Status message
}

pub enum HealthStatus {
    Healthy,
    Warning,
    Error,
    Critical,
}
```

#### `SystemInfo`
System diagnostics.

```rust
pub struct SystemInfo {
    pub cpu_usage: f32,
    pub memory_usage: u64,
    pub disk_usage: u64,
    pub network_tx: u64,
    pub network_rx: u64,
    pub uptime_seconds: u64,
}
```

---

## Built-in Nodes

The HORUS library includes **32 production-ready nodes** with real hardware drivers for sensors, actuators, communication protocols, and control algorithms.

For complete documentation on all built-in nodes, see:

**[Built-in Nodes/Drivers Reference →](/rust/library/built-in-nodes)**

Quick categories:
- **Communication:** I2C, SPI, CAN, Serial, Modbus
- **Motors:** Stepper, BLDC, Dynamixel, Roboclaw, DC Motor, Servo
- **Sensors:** Ultrasonic, Battery, IMU, GPS, Encoder, LiDAR, Camera, Force/Torque
- **Control:** PID, Differential Drive, Odometry, Path Planner, Localization
- **Safety:** Emergency Stop, Safety Monitor, Collision Detector, Digital I/O
- **Input:** Joystick, Keyboard, Image Processor

---

## Example Applications

### SnakeSim
Multi-node snake game demonstration.

**Architecture:**
```
KeyboardInputNode (priority 0)

    ──> SnakeControlNode (priority 2)

    ──> GUINode (priority 3)
```

**Run:**
```bash
cd horus_library/apps/snakesim/snake_scheduler
cargo run --release
```

**Key concepts:**
- Multi-node coordination
- Input handling
- Game state management
- Terminal rendering

### TankSim
Tank physics simulation.

**Run:**
```bash
cd horus_library/apps/tanksim
cargo run --release
```

**Key concepts:**
- Physics integration
- Collision detection
- Controller input

---

## Development Tools

### Sim2D
2D physics simulator with visualization.

**Features:**
- Rapier2D physics engine
- Bevy rendering
- URDF robot models
- Real-time visualization

**Run:**
```bash
cd horus_library/tools/sim2d
cargo run --release
```

**Usage:**
```rust
// Create simulated robot
let robot = Sim2DRobot::from_urdf("robot.urdf")?;

// Connect to HORUS nodes
robot.subscribe_to_hub("cmd_vel");
robot.publish_to_hub("odom");

// Run simulation
simulator.run()?;
```

---

## Feature Flags

Enable optional library features:

```toml
[dependencies]
horus_library = { version = "0.1", features = ["full"] }

# Or specific features:
horus_library = { version = "0.1", features = [
    "control-nodes",     # PID, differential drive
    "input-nodes",       # Keyboard, joystick
    "safety-nodes",      # E-stop, safety monitor
    "basic-sensors",     # Camera, LIDAR, IMU
    "industrial-nodes",  # Modbus
    "raspberry-pi",      # RPi-specific hardware
]}
```

**Available features:**
- `control-nodes` - Control algorithms
- `input-nodes` - Input devices
- `safety-nodes` - Safety monitoring
- `basic-sensors` - Camera, LIDAR, IMU
- `industrial-nodes` - Modbus, industrial protocols
- `raspberry-pi` - Raspberry Pi GPIO
- `opencv-backend` - OpenCV image processing
- `v4l2-backend` - V4L2 camera support

**Hardware features:**
- `i2c-hardware` - I2C bus access
- `spi-hardware` - SPI bus access
- `gpio-hardware` - GPIO/PWM access
- `can-hardware` - CAN bus access
- `serial-hardware` - Serial port access

See [Built-in Nodes - Feature Flags](/built-in-nodes#feature-flags) for hardware requirements.

---

## Best Practices

### Message Type Selection

**Fixed-size types (recommended):**
```rust
// Good - fixed size, safe for shared memory
pub struct LaserScan {
    pub ranges: [f32; 360],  // Fixed array
}
```

**Dynamic types (avoid in messages):**
```rust
// Bad - heap allocation, not safe for shared memory
pub struct BadMessage {
    pub data: Vec<f32>,      // Heap-allocated
    pub name: String,        // Heap-allocated
}
```

### Node Configuration

**Provide sensible defaults:**
```rust
impl CameraNode {
    pub fn new(device: &str) -> Self {
        Self {
            device: device.to_string(),
            width: 640,    // Default resolution
            height: 480,
            fps: 30,       // Default FPS
            // ...
        }
    }

    pub fn with_resolution(mut self, width: u32, height: u32) -> Self {
        self.width = width;
        self.height = height;
        self
    }
}
```

**Usage:**
```rust
// Default configuration
let camera = CameraNode::new("/dev/video0")?;

// Custom configuration
let camera = CameraNode::new("/dev/video0")?
    .with_resolution(1920, 1080)
    .with_fps(60);
```

### Error Handling

**Return results for initialization:**
```rust
impl MyNode {
    pub fn new(config: Config) -> Result<Self, Box<dyn Error>> {
        // Validate configuration
        if config.port == 0 {
            return Err("Invalid port".into());
        }

        // Initialize hardware
        let device = Device::open(config.device)
            .map_err(|e| format!("Failed to open device: {}", e))?;

        Ok(Self { device, config })
    }
}
```

**Handle tick errors gracefully:**
```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    match self.read_sensor() {
        Ok(data) => {
            self.output.send(data, &mut ctx).ok();
        }
        Err(e) => {
            ctx.log_error(&format!("Sensor error: {}", e));
            self.error_count += 1;
        }
    }
}
```

---

## Next Steps

- **[Built-in Nodes/Drivers](/rust/library/built-in-nodes)** - Complete node documentation
- **[Message Types Guide](/concepts/message-types)** - Detailed message documentation
- **[node! Macro](/concepts/node-macro)** - Create custom nodes easily
- **[Examples](/rust/examples/basic-examples)** - Complete applications
- **[API Reference](/rust/api)** - Full API documentation
