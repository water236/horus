---
title: Testing HORUS Applications
description: Unit testing, integration testing, and mocking for HORUS nodes
order: 15
---

# Testing HORUS Applications

Learn how to test your HORUS nodes and applications with complete, runnable examples using Rust's built-in test framework.

## Why Test HORUS Nodes?

Testing ensures:
- **Nodes work in isolation** before integration
- **Message passing is correct** (right topics, right types)
- **Lifecycle methods behave properly** (init, tick, shutdown)
- **Edge cases are handled** (no messages, invalid data, etc.)
- **Refactoring doesn't break functionality**

## Testing Strategies

### 1. Unit Testing a Single Node

Test node behavior without running the scheduler.

### 2. Integration Testing Multiple Nodes

Test nodes communicating through the Hub.

### 3. Mocking Hubs

Isolate nodes by mocking their dependencies.

## Unit Testing a Single Node

Test individual node behavior in isolation.

### Example: Testing a Temperature Sensor

**File: `src/main.rs`**

```rust
use horus::prelude::*;

// The node we want to test
pub struct TemperatureSensor {
    temp_pub: Hub<f32>,
    reading: f32,
}

impl TemperatureSensor {
    pub fn new() -> Result<Self> {
        Ok(Self {
            temp_pub: Hub::new("temperature")?,
            reading: 20.0,
        })
    }

    // Make this public so tests can inspect it
    pub fn get_reading(&self) -> f32 {
        self.reading
    }
}

impl Node for TemperatureSensor {
    fn name(&self) -> &'static str {
        "TemperatureSensor"
    }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info("Sensor initialized");
        Ok(())
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Increment reading each tick
        self.reading += 0.5;

        // Publish temperature
        self.temp_pub.send(self.reading, &mut ctx).ok();
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info("Sensor shutdown");
        Ok(())
    }
}

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();
    scheduler.add(Box::new(TemperatureSensor::new()?), 0, Some(true));
    scheduler.run()?;
    Ok(())
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sensor_initialization() {
        // Test that sensor initializes with correct default value
        let sensor = TemperatureSensor::new().unwrap();
        assert_eq!(sensor.get_reading(), 20.0);
    }

    #[test]
    fn test_sensor_init_lifecycle() {
        let mut sensor = TemperatureSensor::new().unwrap();
        let mut ctx = NodeInfo::new("TemperatureSensor".to_string(), true);

        // Test init() method
        let result = sensor.init(&mut ctx);
        assert!(result.is_ok());
    }

    #[test]
    fn test_sensor_tick_increments_reading() {
        let mut sensor = TemperatureSensor::new().unwrap();

        // Run tick 5 times
        for i in 1..=5 {
            sensor.tick(None);

            // Verify reading increments by 0.5 each tick
            let expected = 20.0 + (i as f32 * 0.5);
            assert_eq!(sensor.get_reading(), expected);
        }
    }

    #[test]
    fn test_sensor_shutdown() {
        let mut sensor = TemperatureSensor::new().unwrap();
        let mut ctx = NodeInfo::new("TemperatureSensor".to_string(), true);

        // Test shutdown() method
        let result = sensor.shutdown(&mut ctx);
        assert!(result.is_ok());
    }
}
```

### Run the Tests

```bash
horus test
```

**Expected Output:**

```
running 4 tests
test tests::test_sensor_initialization ... ok
test tests::test_sensor_init_lifecycle ... ok
test tests::test_sensor_tick_increments_reading ... ok
test tests::test_sensor_shutdown ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured
```

### Key Testing Patterns

**1. Test Node Creation:**
```rust
#[test]
fn test_node_creation() {
    let node = MyNode::new().unwrap();
    assert_eq!(node.some_field, expected_value);
}
```

**2. Test Initialization:**
```rust
#[test]
fn test_init() {
    let mut node = MyNode::new().unwrap();
    let mut ctx = NodeInfo::new("MyNode".to_string(), true);
    assert!(node.init(&mut ctx).is_ok());
}
```

**3. Test Tick Logic:**
```rust
#[test]
fn test_tick_logic() {
    let mut node = MyNode::new().unwrap();
    node.tick(None);
    // Verify state changes
    assert_eq!(node.counter, 1);
}
```

**4. Test Shutdown:**
```rust
#[test]
fn test_shutdown() {
    let mut node = MyNode::new().unwrap();
    let mut ctx = NodeInfo::new("MyNode".to_string(), true);
    assert!(node.shutdown(&mut ctx).is_ok());
}
```

## Testing Multiple Nodes Together

Test nodes communicating through topics.

### Example: Publisher-Subscriber Test

**File: `src/main.rs`**

```rust
use horus::prelude::*;
use std::sync::{Arc, Mutex};

// Publisher node
pub struct PublisherNode {
    data_pub: Hub<f32>,
}

impl PublisherNode {
    pub fn new() -> Result<Self> {
        Ok(Self {
            data_pub: Hub::new("test_data")?,
        })
    }
}

impl Node for PublisherNode {
    fn name(&self) -> &'static str {
        "PublisherNode"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        self.data_pub.send(42.0, &mut ctx).ok();
    }
}

// Subscriber node that stores received data
pub struct SubscriberNode {
    data_sub: Hub<f32>,
    received: Arc<Mutex<Vec<f32>>>,
}

impl SubscriberNode {
    pub fn new(received: Arc<Mutex<Vec<f32>>>) -> Result<Self> {
        Ok(Self {
            data_sub: Hub::new("test_data")?,
            received,
        })
    }
}

impl Node for SubscriberNode {
    fn name(&self) -> &'static str {
        "SubscriberNode"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(data) = self.data_sub.recv(&mut ctx) {
            self.received.lock().unwrap().push(data);
        }
    }
}

fn main() -> Result<()> {
    let received = Arc::new(Mutex::new(Vec::new()));

    let mut scheduler = Scheduler::new();
    scheduler.add(Box::new(PublisherNode::new()?), 0, Some(true));
    scheduler.add(Box::new(SubscriberNode::new(received)?), 1, Some(true));
    scheduler.run()?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_pubsub_communication() {
        // Shared storage for received messages
        let received = Arc::new(Mutex::new(Vec::new()));

        // Create publisher and subscriber
        let mut pub_node = PublisherNode::new().unwrap();
        let mut sub_node = SubscriberNode::new(Arc::clone(&received)).unwrap();

        // Publish a message
        pub_node.tick(None);

        // Small delay to allow IPC (shared memory needs time to propagate)
        thread::sleep(Duration::from_millis(10));

        // Subscriber receives the message
        sub_node.tick(None);

        // Verify message was received
        let data = received.lock().unwrap();
        assert_eq!(data.len(), 1);
        assert_eq!(data[0], 42.0);
    }

    #[test]
    fn test_multiple_messages() {
        let received = Arc::new(Mutex::new(Vec::new()));

        let mut pub_node = PublisherNode::new().unwrap();
        let mut sub_node = SubscriberNode::new(Arc::clone(&received)).unwrap();

        // Publish 5 messages
        for _ in 0..5 {
            pub_node.tick(None);
            thread::sleep(Duration::from_millis(5));
            sub_node.tick(None);
        }

        // Verify all messages received
        let data = received.lock().unwrap();
        assert_eq!(data.len(), 5);
        for value in data.iter() {
            assert_eq!(*value, 42.0);
        }
    }
}
```

### Run Integration Tests

```bash
horus test test_pubsub_communication -- --test-threads=1
```

**Why `--test-threads=1`?**
- Prevents tests from running in parallel
- Avoids shared memory conflicts between tests
- Ensures deterministic behavior

**Expected Output:**

```
running 2 tests
test tests::test_pubsub_communication ... ok
test tests::test_multiple_messages ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
```

## Mocking Hubs for Isolated Tests

Test nodes without real Hub connections.

### Example: Mock Hub for Testing

```rust
use horus::prelude::*;

// Node that processes temperature data
pub struct TemperatureProcessor {
    input_sub: Hub<f32>,
    output_pub: Hub<f32>,
}

impl TemperatureProcessor {
    pub fn new() -> Result<Self> {
        Ok(Self {
            input_sub: Hub::new("input_temp")?,
            output_pub: Hub::new("output_temp")?,
        })
    }

    // Public method for testing business logic
    pub fn process_temperature(&self, temp: f32) -> f32 {
        // Convert Celsius to Fahrenheit
        temp * 9.0 / 5.0 + 32.0
    }
}

impl Node for TemperatureProcessor {
    fn name(&self) -> &'static str {
        "TemperatureProcessor"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(celsius) = self.input_sub.recv(&mut ctx) {
            let fahrenheit = self.process_temperature(celsius);
            self.output_pub.send(fahrenheit, &mut ctx).ok();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_temperature_conversion_logic() {
        // Test business logic WITHOUT Hub
        let processor = TemperatureProcessor::new().unwrap();

        // Test known conversions
        assert_eq!(processor.process_temperature(0.0), 32.0);
        assert_eq!(processor.process_temperature(100.0), 212.0);
        assert_eq!(processor.process_temperature(-40.0), -40.0);
    }

    #[test]
    fn test_with_mock_data() {
        let mut processor = TemperatureProcessor::new().unwrap();

        // We can't easily mock Hub, but we can test the logic
        // by calling process_temperature directly
        let celsius_readings = vec![0.0, 10.0, 20.0, 30.0, 100.0];
        let expected_fahrenheit = vec![32.0, 50.0, 68.0, 86.0, 212.0];

        for (celsius, expected) in celsius_readings.iter().zip(expected_fahrenheit.iter()) {
            let result = processor.process_temperature(*celsius);
            assert_eq!(result, *expected);
        }
    }
}
```

### Testing Strategy Without Hub Mocks

Since HORUS Hubs use real shared memory, full mocking is complex. Instead:

**1. Extract Business Logic:**
```rust
// Good: Business logic in testable method
pub fn process_temperature(&self, temp: f32) -> f32 {
    temp * 9.0 / 5.0 + 32.0
}

// Test this directly without Hub
#[test]
fn test_logic() {
    assert_eq!(node.process_temperature(0.0), 32.0);
}
```

**2. Test Tick with Real Hubs:**
```rust
// Use real Hubs in tests (they're lightweight)
#[test]
fn test_with_real_hub() {
    let mut node = MyNode::new().unwrap();
    node.tick(None);
    // Verify behavior
}
```

**3. Use Shared State for Verification:**
```rust
// Store results in node for verification
pub struct TestNode {
    pub last_result: Option<f32>,
}

#[test]
fn test_result() {
    let mut node = TestNode::new();
    node.tick(None);
    assert_eq!(node.last_result, Some(42.0));
}
```

## Complete Testing Example

A fully tested 3-node system.

**File: `src/main.rs`**

```rust
use horus::prelude::*;
use std::sync::{Arc, Mutex};

// Node 1: Generate numbers
pub struct GeneratorNode {
    output_pub: Hub<u32>,
    counter: u32,
}

impl GeneratorNode {
    pub fn new() -> Result<Self> {
        Ok(Self {
            output_pub: Hub::new("numbers")?,
            counter: 0,
        })
    }
}

impl Node for GeneratorNode {
    fn name(&self) -> &'static str { "GeneratorNode" }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        self.counter += 1;
        self.output_pub.send(self.counter, &mut ctx).ok();
    }
}

// Node 2: Double the numbers
pub struct DoublerNode {
    input_sub: Hub<u32>,
    output_pub: Hub<u32>,
}

impl DoublerNode {
    pub fn new() -> Result<Self> {
        Ok(Self {
            input_sub: Hub::new("numbers")?,
            output_pub: Hub::new("doubled")?,
        })
    }
}

impl Node for DoublerNode {
    fn name(&self) -> &'static str { "DoublerNode" }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(n) = self.input_sub.recv(&mut ctx) {
            self.output_pub.send(n * 2, &mut ctx).ok();
        }
    }
}

// Node 3: Collect results
pub struct CollectorNode {
    input_sub: Hub<u32>,
    collected: Arc<Mutex<Vec<u32>>>,
}

impl CollectorNode {
    pub fn new(collected: Arc<Mutex<Vec<u32>>>) -> Result<Self> {
        Ok(Self {
            input_sub: Hub::new("doubled")?,
            collected,
        })
    }
}

impl Node for CollectorNode {
    fn name(&self) -> &'static str { "CollectorNode" }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(n) = self.input_sub.recv(&mut ctx) {
            self.collected.lock().unwrap().push(n);
        }
    }
}

fn main() -> Result<()> {
    let collected = Arc::new(Mutex::new(Vec::new()));

    let mut scheduler = Scheduler::new();
    scheduler.add(Box::new(GeneratorNode::new()?), 0, Some(true));
    scheduler.add(Box::new(DoublerNode::new()?), 1, Some(true));
    scheduler.add(Box::new(CollectorNode::new(collected)?), 2, Some(true));

    scheduler.run()?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_generator_node() {
        let mut node = GeneratorNode::new().unwrap();

        // Initial state
        assert_eq!(node.counter, 0);

        // After 3 ticks
        for _ in 0..3 {
            node.tick(None);
        }

        assert_eq!(node.counter, 3);
    }

    #[test]
    fn test_pipeline() {
        let collected = Arc::new(Mutex::new(Vec::new()));

        let mut gen = GeneratorNode::new().unwrap();
        let mut dbl = DoublerNode::new().unwrap();
        let mut col = CollectorNode::new(Arc::clone(&collected)).unwrap();

        // Run 5 iterations of the pipeline
        for _ in 0..5 {
            gen.tick(None);
            thread::sleep(Duration::from_millis(5));
            dbl.tick(None);
            thread::sleep(Duration::from_millis(5));
            col.tick(None);
        }

        // Verify results: 1*2=2, 2*2=4, 3*2=6, 4*2=8, 5*2=10
        let results = collected.lock().unwrap();
        assert_eq!(*results, vec![2, 4, 6, 8, 10]);
    }
}
```

### Run All Tests

```bash
horus test -- --test-threads=1
```

**Output:**

```
running 2 tests
test tests::test_generator_node ... ok
test tests::test_pipeline ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
```

## Best Practices

### 1. Test Business Logic Separately

Extract pure functions for easy testing:

```rust
// Good: Pure function (easy to test)
fn calculate_velocity(distance: f32, time: f32) -> f32 {
    distance / time
}

#[test]
fn test_velocity() {
    assert_eq!(calculate_velocity(100.0, 10.0), 10.0);
}
```

### 2. Use Arc for Shared Test Data

Share data between nodes for verification:

```rust
let results = Arc::new(Mutex::new(Vec::new()));
let node = TestNode::new(Arc::clone(&results))?;

// Later in test
assert_eq!(results.lock().unwrap().len(), 5);
```

### 3. Add Small Delays for IPC

Shared memory needs time to propagate:

```rust
pub_node.tick(None);
thread::sleep(Duration::from_millis(10));  // Allow IPC
sub_node.tick(None);
```

### 4. Run Tests Sequentially

Prevent shared memory conflicts:

```bash
horus test -- --test-threads=1
```

### 5. Test Edge Cases

```rust
#[test]
fn test_no_messages() {
    let mut node = SubscriberNode::new().unwrap();
    node.tick(None);  // Should handle gracefully
}

#[test]
fn test_invalid_data() {
    let result = node.process(-1.0);
    assert!(result.is_err());
}
```

## Running Tests with horus test

### Basic Commands

```bash
# Run all tests
horus test

# Run tests sequentially (recommended for HORUS)
horus test -- --test-threads=1

# Run specific test
horus test test_sensor_initialization

# Run tests with output
horus test -- --nocapture

# Run tests matching pattern
horus test sensor
```

### Test Organization

```rust
#[cfg(test)]
mod tests {
    use super::*;

    mod unit_tests {
        use super::*;

        #[test]
        fn test_creation() { /* ... */ }
    }

    mod integration_tests {
        use super::*;

        #[test]
        fn test_pipeline() { /* ... */ }
    }
}
```

## Troubleshooting Tests

### Issue: Tests Fail Randomly

**Cause:** Shared memory conflicts from parallel tests

**Fix:**
```bash
horus test -- --test-threads=1
```

### Issue: "Topic not found" Errors

**Cause:** Hub created in one test affects another

**Fix:** Use unique topic names per test:
```rust
Hub::new("test_topic_1")?  // Test 1
Hub::new("test_topic_2")?  // Test 2
```

### Issue: Messages Not Received

**Cause:** IPC needs time to propagate

**Fix:** Add small delay:
```rust
thread::sleep(Duration::from_millis(10));
```

## Next Steps

- **[Examples](/rust/examples/basic-examples)** - See complete tested applications
- **[Core Concepts - Nodes](/concepts/core-concepts-nodes)** - Understand node lifecycle
- **[Monitor](/development/monitor)** - Debug with visual monitoring
- **[Troubleshooting](/troubleshooting)** - Fix common runtime issues
