---
title: Quick Start
description: Build your first HORUS application in 10 minutes
order: 3
---

# Quick Start

This tutorial demonstrates building a temperature monitoring system with HORUS. Estimated time: 10 minutes.

## What We're Building

A system with two components:
1. **Sensor** - Generates temperature readings
2. **Monitor** - Displays the readings

They'll communicate using HORUS's ultra-fast shared memory.

## Step 1: Create a New Project

```bash
# Create a new HORUS project
horus new temperature-monitor

# Select options in the interactive prompt:
# Language: Rust (option 2)
# Use macros: No (we'll learn the basics first)

cd temperature-monitor
```

This creates:
- `main.rs` - Your code (we'll customize this)
- `horus.yaml` - Dependencies and project metadata
- `.horus/` - Auto-managed environment (local workspace + global cache)

> **Note**: `.horus/` is automatically managed. For Rust projects, HORUS generates `Cargo.toml` from your `horus.yaml` using path references (no source copying). See [Environment Management](/environment-management#solving-dependency-hell) for details.

## Step 2: Write the Code

Replace the generated `main.rs` with this complete example:

```rust
use horus::prelude::*;
use std::time::Duration;

//===========================================
// SENSOR NODE - Generates temperature data
//===========================================

struct TemperatureSensor {
    publisher: Hub<f32>,
    temperature: f32,
}

impl TemperatureSensor {
    fn new() -> Result<Self> {
        Ok(Self {
            publisher: Hub::new("temperature")?,
            temperature: 20.0,
        })
    }
}

impl Node for TemperatureSensor {
    fn name(&self) -> &'static str {
        "TemperatureSensor"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Simulate temperature change
        self.temperature += 0.1;

        // Send the reading
        self.publisher.send(self.temperature, &mut ctx).ok();

        // Wait 1 second before next reading
        std::thread::sleep(Duration::from_secs(1));
    }
}

//============================================
// MONITOR NODE - Displays temperature data
//============================================

struct TemperatureMonitor {
    subscriber: Hub<f32>,
}

impl TemperatureMonitor {
    fn new() -> Result<Self> {
        Ok(Self {
            subscriber: Hub::new("temperature")?,
        })
    }
}

impl Node for TemperatureMonitor {
    fn name(&self) -> &'static str {
        "TemperatureMonitor"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Check for new temperature readings
        if let Some(temp) = self.subscriber.recv(&mut ctx) {
            println!("Temperature: {:.1}°C", temp);
        }
    }
}

//============================================
// MAIN - Run both nodes
//============================================

fn main() -> Result<()> {
    eprintln!("Starting temperature monitoring system...\n");

    // Create the scheduler
    let mut scheduler = Scheduler::new();

    // Add both nodes
    // Priority 0 = sensor runs first
    // Priority 1 = monitor runs second
    // Logging enabled (Some(true)) to see message flow
    scheduler.add(
        Box::new(TemperatureSensor::new()?),
        0,
        Some(true)
    );
    scheduler.add(
        Box::new(TemperatureMonitor::new()?),
        1,
        Some(true)
    );

    // Run forever (press Ctrl+C to stop)
    scheduler.run()?;

    Ok(())
}
```

## Step 3: Run It!

```bash
horus run --release
```

HORUS will automatically:
- Scan dependencies from `horus.yaml`
- Generate `.horus/Cargo.toml` from dependencies
- Compile with Cargo (optimized)
- Execute your program

You'll see:

```
Starting temperature monitoring system...

Temperature: 20.1°C
Temperature: 20.2°C
Temperature: 20.3°C
Temperature: 20.4°C
...
```

Press **Ctrl+C** to stop.

## Understanding the Code

### The Hub - Communication Channel

```rust
// Create a publisher (sends data)
publisher: Hub::new("temperature")?

// Create a subscriber (receives data)
subscriber: Hub::new("temperature")?
```

Both use the same topic name (`"temperature"`). The `Hub` manages all shared memory operations automatically.

### The Node Trait - Component Lifecycle

Each component implements the `Node` trait:

```rust
impl Node for TemperatureSensor {
    // Give your node a name
    fn name(&self) -> &'static str {
        "TemperatureSensor"
    }

    // This runs repeatedly
    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        // Your logic here
    }
}
```

### The Scheduler - Running Everything

The scheduler runs your nodes in priority order:

```rust
let mut scheduler = Scheduler::new();

// Priority 0 = highest (runs first)
scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));

// Priority 1 = lower (runs after priority 0)
scheduler.add(Box::new(MonitorNode::new()?), 1, Some(true));

// Run forever
scheduler.run()?;
```

## Running Nodes in Separate Processes

The example above runs both nodes in a **single process**. For multi-process applications (e.g., separate backend + GUI), you need a shared `session_id`.

### Option 1: Configure session_id in horus.yaml

Since `horus new` now auto-generates a `session_id`, you can run nodes separately:

```yaml
# horus.yaml (auto-generated)
name: temperature-monitor
session_id: "temperature-monitor-session"  # Shared session
dependencies:
  - horus@0.1.0
```

Now you can run nodes in different terminals:

```bash
# Terminal 1: Run sensor
horus run sensor.rs

# Terminal 2: Run monitor
horus run monitor.rs
```

Both share the same session → communication works!

### Option 2: Use Glob Pattern

Run multiple files together (auto-shares session):

```bash
horus run "*.rs"  # All Rust files run as separate processes
```

### Option 3: Use Global Hubs

For cross-session communication (e.g., system-wide services):

```rust
// Instead of Hub::new()
let hub: Hub<f32> = Hub::new_global("temperature")?;
```

Global hubs work across ALL sessions automatically.

> [TIP] **See [Configuration](/configuration#session-management)** for details on session_id and [Shared Memory](/core-concepts-shared-memory#session-management) for how sessions work.

## Next Steps

### Add More Features

Try modifying the code:

**1. Add a temperature alert:**
```rust
impl Node for TemperatureMonitor {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(temp) = self.subscriber.recv(&mut ctx) {
            if let Some(ref mut c) = ctx {
                c.log_info(&format!("Temperature: {:.1}°C", temp));

                // Alert if temperature exceeds threshold
                if temp > 25.0 {
                    c.log_warning("Temperature too high!");
                }
            }
        }
    }
}
```

**2. Add a second sensor:**
```rust
// In main():
scheduler.add(Box::new(HumiditySensor::new()?), 0, Some(true));
scheduler.add(Box::new(HumidityMonitor::new()?), 1, Some(true));
```

**3. Save data to a file:**
```rust
use std::fs::OpenOptions;
use std::io::Write;

impl Node for TemperatureMonitor {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(temp) = self.subscriber.recv(&mut ctx) {
            // Display
            if let Some(ref mut c) = ctx {
                c.log_info(&format!("Temperature: {:.1}°C", temp));
            }

            // Save to file
            let mut file = OpenOptions::new()
                .create(true)
                .append(true)
                .open("temperature.log")
                .unwrap();
            writeln!(file, "{:.1}", temp).ok();
        }
    }
}
```

### Learn More Concepts

Now that you've built your first app, learn the details:

**Core Concepts:**
- **[Nodes](/concepts/core-concepts-nodes)** - Deep dive into the Node pattern
- **[Hub](/concepts/core-concepts-hub)** - How ultra-fast communication works
- **[Scheduler](/concepts/core-concepts-scheduler)** - Priority-based execution

**Make Development Easier:**
- **[node! Macro](/concepts/node-macro)** - Eliminate boilerplate code
- **[CLI Reference](/development/cli-reference)** - All the `horus` commands
- **[Monitor](/development/monitor)** - Monitor your application visually

**See More Examples:**
- **[Examples](/rust/examples/basic-examples)** - Real applications you can run
- **[Multi-Language](/concepts/multi-language)** - Use Python instead

## Common Questions

### Why do I need `Box::new()`?

Nodes are stored polymorphically (different types in one collection). `Box::new()` puts them on the heap so they can be stored together.

### What's `Option<&mut NodeInfo>`?

It's an optional context that provides:
- Logging functions
- Timing information
- Node metadata

Pass it along to `send()` and `recv()` for automatic logging.

### Can I use async/await?

The scheduler uses tokio internally, but nodes use simple sync code. This keeps things simple and predictable.

### How do I stop the application?

Press **Ctrl+C**. The scheduler handles graceful shutdown automatically.

### Where does the data go?

Data is stored in platform-specific shared memory:
- **Linux:** `/dev/shm/horus/`
- **macOS:** `/tmp/horus/`
- **Windows:** `%TEMP%\horus\`

Check it out (Linux):
```bash
ls -lh /dev/shm/horus/
```

## Troubleshooting

### "Failed to create Hub"

Another program might be using the same topic name. Pick a unique name:

```rust
Hub::new("temperature_sensor_1")?
```

### "Address already in use"

The shared memory file exists from a previous run. Remove it:

```bash
# Linux
rm -f /dev/shm/horus/topic_temperature
# macOS
rm -f /tmp/horus/topic_temperature
```

Or use a different topic name.

### Nothing prints

Make sure both nodes are added:

```rust
scheduler.add(Box::new(Sensor::new()?), 0, Some(true));
scheduler.add(Box::new(Monitor::new()?), 1, Some(true));
```

## What You've Learned

How to create a HORUS project
The Node trait pattern
Using Hub for communication
Running multiple nodes with a Scheduler
Sending and receiving messages

## Ready for More?

Your next steps:

1. **[Use the node! macro](/concepts/node-macro)** to eliminate boilerplate
2. **[Run the examples](/rust/examples/basic-examples)** to see real applications
3. **[Open the monitor](/development/monitor)** to monitor your system

For issues, see the **[Troubleshooting Guide](/troubleshooting)**.
