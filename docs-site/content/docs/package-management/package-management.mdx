---
title: Package Management
description: Install, publish, and manage reusable HORUS components
order: 30
---

# Package Management

> **Note**: Publishing packages requires the registry backend to be deployed. Installing public packages works immediately.

HORUS provides a comprehensive package management system for sharing and discovering robotics components. Create reusable nodes, message types, and algorithms that the community can use.

## Overview

The package system allows you to:

- **Install packages** from multiple sources (HORUS registry, crates.io, PyPI)
- **Publish your work** for others to use
- **Manage dependencies** automatically
- **Version control** with semantic versioning
- **Search and discover** community packages

## Package Sources

HORUS supports installing packages from multiple sources:

| Source | Description | Example |
|--------|-------------|---------|
| **HORUS Registry** | Curated robotics packages | `horus pkg install pid-controller` |
| **crates.io** | Rust ecosystem packages | `horus pkg install serde` |
| **PyPI** | Python ecosystem packages | `horus pkg install numpy` |
| **Git** | Git repositories (via `horus.yaml`) | See [Configuration](/package-management/configuration) |
| **Local Path** | Local filesystem (via `horus.yaml`) | See [Configuration](/package-management/configuration) |

## Quick Start

### Installing a Package

```bash
# Install from HORUS registry
horus pkg install pid-controller

# Install from crates.io (auto-detected)
horus pkg install serde
horus pkg install tokio

# Install from PyPI (auto-detected)
horus pkg install numpy
horus pkg install opencv-python

# Install specific version
horus pkg install serde -v 1.0.200

# Install globally (share across all projects)
horus pkg install sensor-drivers -g
```

### Automatic Source Detection

HORUS automatically detects the package source:

1. First checks HORUS registry
2. Then checks both PyPI and crates.io
3. If found in multiple sources, prompts you to choose:

```
Package 'package_name' found in BOTH PyPI and crates.io

Which package source do you want to use?
  [1] [PYTHON] PyPI (Python package)
  [2] [RUST] crates.io (Rust binary)
  [3] [FAIL] Cancel installation

Choice [1-3]:
```

### System Package Detection

If a package is already installed system-wide, HORUS offers to reuse it:

```
Package 'ripgrep' v14.0.0 already installed system-wide

  [1] Use system package (no download)
  [2] Install fresh copy to HORUS
  [3] Cancel

Choice [1-3]:
```

**What happens during installation:**
1. Detects package source (HORUS registry, crates.io, or PyPI)
2. Downloads package from the appropriate source
3. Resolves dependencies automatically
4. Caches locally in `~/.horus/cache/` or `.horus/packages/`
5. Makes package available for use

### Using an Installed Package

```rust
// In your main.rs or any file
use pid_controller::PIDNode;
use horus::prelude::*;

fn main() {
    let mut scheduler = Scheduler::new();

    // Use the installed package
    let pid = PIDNode::new(1.0, 0.1, 0.01);
    scheduler.add(Box::new(pid), 5, Some(true));

    scheduler.run().expect("Scheduler failed");
}
```

### Publishing Your Package

```bash
# 1. Authenticate first (one-time)
horus auth login

# 2. Navigate to your project
cd my-awesome-controller

# 3. Publish
horus pkg publish
```

## Package Locations

### Local Packages

**Project-local** (default):
```
my_project/
── .horus/
   ── packages/
       ── pid-controller@1.0.0/      # HORUS registry
       ── serde@1.0.200/             # crates.io
       ── pypi_numpy@1.24.0/         # PyPI (prefixed with pypi_)
── src/
    ── main.rs
```

**Why use local:**
- Different projects can use different versions
- Clean separation per project
- Easy to delete with project

### Global Packages

**System-wide** (installed with `-g` flag):
```
~/.horus/
── cache/
    ── pid-controller@1.0.0/         # HORUS registry
    ── serde@1.0.200/                # crates.io
    ── pypi_numpy@1.24.0/            # PyPI packages
    ── git_abc123/                   # Git dependencies (via horus.yaml)
```

**Naming conventions by source:**
| Source | Directory Format | Example |
|--------|------------------|---------|
| HORUS Registry | `<name>@<version>/` | `pid-controller@1.0.0/` |
| crates.io | `<name>@<version>/` | `serde@1.0.200/` |
| PyPI | `pypi_<name>@<version>/` | `pypi_numpy@1.24.0/` |
| Git | `git_<hash>/` | `git_abc123def/` |

**Why use global:**
- Share common packages across all projects
- Save disk space (one copy for everything)
- Faster install after first download

### Priority Order & Smart Dependency Resolution

When resolving packages, HORUS checks in this order:

**1. Project-local `.horus/packages/` (highest priority)**
- Checked first, ALWAYS wins
- Can be symlink to global OR real directory
- Enables local override of broken global packages

**2. Global cache `~/.horus/cache/`**
- Only checked if not found locally
- Shared across all projects
- Version-specific directories (e.g., `serde@1.0.228/`)

**3. System install `/usr/local/lib/horus/` (if available)**
- Last resort fallback

**Smart Installation Behavior:**

When you run `horus pkg install`, HORUS automatically chooses the best strategy:

```bash
# Default behavior (no flags)
horus pkg install serde

# If package exists in global cache:
#    Install to global cache
#    Create symlink: .horus/packages/serde -> ~/.horus/cache/serde@1.0.228/
#    Disk efficient!

# If package NOT in global cache:
#    Install directly to .horus/packages/serde@1.0.228/
#    No symlink, real directory
#    Isolated from global!
```

**Override Broken Global Cache:**

Local packages always win, so you can override corrupted global packages:

```bash
# Scenario: Global cache has broken serde@1.0.228
~/.horus/cache/serde@1.0.228/  # Corrupted

# Fix: Install working version locally
rm .horus/packages/serde  # Remove symlink to broken global
horus pkg install serde -v 1.0.150  # Install working version locally

# Result:
.horus/packages/serde@1.0.150/  # Real directory, not symlink
# horus run will use this, ignoring broken global!
```

**Benefits:**
- **Local override** - Bypass broken global packages
- **Version isolation** - Different projects can use different versions
- **Disk efficient** - Shares global cache when possible
- **Zero config** - Works automatically

See [Environment Management](/environment-management#solving-dependency-hell) for more details on how this solves dependency hell.

## Package Commands

### `horus pkg install`

Install packages from multiple sources (HORUS registry, crates.io, PyPI).

**Usage:**
```bash
horus pkg install <package> [OPTIONS]
```

**Options:**
- `-v, --ver <VERSION>` - Install specific version (default: latest)
- `-g, --global` - Install to global cache
- `-t, --target <NAME>` - Target workspace/project name

**Examples:**

```bash
# From HORUS registry
horus pkg install pid-controller
horus pkg install motion-planner -v 2.0.1

# From crates.io (auto-detected)
horus pkg install serde
horus pkg install tokio -v 1.35.0
horus pkg install clap

# From PyPI (auto-detected)
horus pkg install numpy
horus pkg install opencv-python -v 4.8.0
horus pkg install torch

# Global installation
horus pkg install serde -g

# Install to specific workspace
horus pkg install pid-controller -t my-project
```

#### Installing from crates.io

When installing Rust packages from crates.io, HORUS uses `cargo install` under the hood:

```bash
horus pkg install ripgrep
```

**Output:**
```
Installing ripgrep from crates.io...
  Compiling ripgrep...
  Installing with cargo...

Package installed: ripgrep@14.0.0
Location: ~/.horus/cache/ripgrep@14.0.0/
```

**Requirements:**
- Rust toolchain must be installed (`rustup`)
- `cargo` must be available in PATH

#### Installing from PyPI

When installing Python packages from PyPI, HORUS uses `pip install --target` to isolate packages:

```bash
horus pkg install numpy
```

**Output:**
```
Installing numpy from PyPI...
  Downloading numpy-1.24.0...
  Installing to .horus/packages/pypi_numpy@1.24.0/

Package installed: numpy@1.24.0
Location: .horus/packages/pypi_numpy@1.24.0/
```

**Requirements:**
- Python 3.x must be installed
- `pip` must be available in PATH

#### Using Python Packages

After installing a PyPI package, use it in your Python nodes:

```python
# In your Python node
import sys
sys.path.insert(0, '.horus/packages/pypi_numpy@1.24.0')

import numpy as np
# Or HORUS automatically adds package paths when using horus run
```

When using `horus run`, Python package paths are automatically configured.

**HORUS Registry Output:**
```
Installing pid-controller@1.2.0...
 Downloaded (245 KB)
 Extracted to .horus/packages/pid-controller@1.2.0/
 Installed dependencies: control-utils@1.0.0
 Build successful

Package installed: pid-controller@1.2.0
Location: .horus/packages/pid-controller@1.2.0/

Usage:
  use pid_controller::PIDNode;
```

### `horus pkg remove`

Uninstall a package.

**Usage:**
```bash
horus pkg remove <package>
```

**Options:**
- `-g, --global` - Remove from global cache
- `-t, --target <NAME>` - Target workspace/project name

**Examples:**

```bash
# Remove local package
horus pkg remove motion-planner

# Remove from global cache
horus pkg remove common-utils -g

# Remove from specific workspace
horus pkg remove pid-controller -t my-project
```

**Output:**
```
Removing pid-controller@1.2.0...
 Removed from .horus/packages/
 Freed 892 KB

Package removed: pid-controller@1.2.0
```

### `horus pkg list`

List installed packages or search the registry.

**Usage:**
```bash
horus pkg list [QUERY] [OPTIONS]
```

**Options:**
- `-g, --global` - List global cache packages
- `-a, --all` - List all (local + global)

**List Local Packages:**
```bash
horus pkg list
```

**Output:**
```
Local packages:
  pid-controller 1.2.0
  motion-planner 2.0.1
  sensor-drivers 1.5.0
```

**List Global Cache:**
```bash
horus pkg list -g
```

**Search Registry:**
```bash
# Search by keyword
horus pkg list sensor
```

**Output:**
```
Found 3 package(s):
  sensor-fusion 2.1.0 - Kalman filter fusion
  sensor-drivers 1.5.0 - LIDAR/IMU/camera drivers
  sensor-calibration 1.0.0 - Calibration tools
```

### `horus pkg unpublish`

Remove a package version from the registry (irreversible!).

**Usage:**
```bash
horus pkg unpublish <package> <version> [OPTIONS]
```

**Options:**
- `-y, --yes` - Skip confirmation prompt

**Examples:**
```bash
# Unpublish a specific version
horus pkg unpublish my-package 1.0.0

# Skip confirmation prompt
horus pkg unpublish my-package 1.0.0 -y
```

**Output:**
```
Unpublishing my-package v1.0.0...

Warning: This action is IRREVERSIBLE and will:
  • Delete my-package v1.0.0 from the registry
  • Make this version unavailable for download
  • Cannot be undone

Type the package name 'my-package' to confirm: my-package

 Successfully unpublished my-package v1.0.0
   The package is no longer available on the registry
```

> **Note**: Detailed package information can be viewed on the registry web interface at https://marketplace.horus-registry.dev

## Authentication (for Publishing)

> **Note**: Registry publishing and private resources require the registry backend to be deployed. GitHub authentication is fully functional.

Authentication is required for publishing packages, sharing environments, and accessing private registry resources. HORUS uses GitHub OAuth for interactive login and API keys for automated systems.

###Authentication Overview

**Authentication methods:**
- **GitHub OAuth** - Interactive login via browser (recommended for development)
- **API Keys** - Long-lived tokens for CI/CD and automation
- **Environment Variables** - For containerized deployments

**What requires authentication:**
- Publishing packages (`horus pkg publish`)
- Publishing environments (`horus env freeze --publish`)
- Accessing private packages
- Managing your published packages

**What doesn't require authentication:**
- Installing public packages (`horus pkg install`)
- Searching registry (`horus pkg list`)
- Restoring public environments (`horus env restore`)
- Using installed packages

### Quick Authentication Setup

**Interactive Login:**
```bash
# Login with GitHub
horus auth login
```

**What happens:**
1. Opens browser to GitHub OAuth page
2. You authorize HORUS Registry
3. Token saved to `~/.horus/credentials`
4. Ready to publish!

**Check Authentication:**
```bash
# Verify you're logged in
horus auth whoami
```

**Logout:**
```bash
# Remove credentials
horus auth logout
```

### GitHub OAuth Login

**First-Time Setup:**
```bash
# Run login command
horus auth login
```

**Output:**
```
Opening GitHub OAuth page in browser...

If browser doesn't open automatically, visit:
  https://github.com/login/oauth/authorize?client_id=...

Waiting for authorization...
```

**In browser:**
1. See "Authorize HORUS Registry" page
2. Review permissions requested:
   - Read user profile
   - Read email address
3. Click "Authorize horus-registry"
4. Redirected to success page

**Back in terminal:**
```
Authorization successful!
Token saved to ~/.horus/credentials

Authenticated as: your-username
Email: you@example.com

You can now publish packages with:
  horus pkg publish
```

**What Gets Stored:**

Credentials file: `~/.horus/credentials`

```json
{
  "provider": "github",
  "username": "your-username",
  "email": "you@example.com",
  "token": "gho_abc123def456...",
  "refresh_token": "gho_xyz789...",
  "expires_at": null,
  "created_at": "2025-10-09T14:30:00Z"
}
```

**Security:**
- File permissions: `0600` (read/write owner only)
- Tokens encrypted at rest
- Auto-refresh before expiration
- Revocable via GitHub settings

**Token Permissions:**

Required scopes:
- `read:user` - Read your GitHub profile
- `user:email` - Read your email address

Not requested:
- No write access to repositories
- No access to private repositories
- No access to organizations

**Revoking Access:**

Via GitHub:
1. Go to https://github.com/settings/applications
2. Find "HORUS Registry" under "Authorized OAuth Apps"
3. Click "Revoke"

Via CLI:
```bash
horus auth logout
```

### API Keys (for CI/CD)

API keys are long-lived tokens for automated systems like CI/CD pipelines.

**Generating API Keys:**

```bash
# Interactive generation
horus auth generate-key
```

**Interactive prompts:**
```
Generating API key...

Key name (for identification): CI/CD Pipeline
Environment (optional): production
Description (optional): GitHub Actions deployment

Generated API key:
  horus_live_abc123def456ghi789jkl012mno345pqr678stu901

WARNING: Copy this key now. It won't be shown again.

Save to environment variable:
  export HORUS_API_KEY=horus_live_abc123def456ghi789jkl012mno345pqr678stu901

Or use in CI:
  # GitHub Actions
  - name: Publish
    env:
      HORUS_API_KEY: ${{ secrets.HORUS_API_KEY }}
    run: horus pkg publish
```

**With flags:**
```bash
horus auth generate-key \
  --name "GitHub Actions" \
  --environment "production"
```

**Using API Keys:**

Environment variable (recommended):
```bash
# Set for session
export HORUS_API_KEY=horus_live_abc123...

# Use horus commands
horus pkg publish
```

Credentials file:
```bash
# Save to file manually
echo '{"api_key":"horus_live_abc123..."}' > ~/.horus/credentials
```

> **Note**: Managing API keys (listing, revoking, etc.) is currently done through the registry web interface at https://marketplace.horus-registry.dev

### CI/CD Integration

**GitHub Actions:**

Workflow file (`.github/workflows/publish.yml`):
```yaml
name: Publish to HORUS Registry

on:
  push:
    tags:
      - 'v*'

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Install HORUS
        run: |
          git clone https://github.com/softmata/horus.git /tmp/horus
          cd /tmp/horus && ./install.sh

      - name: Publish Package
        env:
          HORUS_API_KEY: ${{ secrets.HORUS_API_KEY }}
        run: |
          horus pkg publish --yes

      - name: Publish Environment
        env:
          HORUS_API_KEY: ${{ secrets.HORUS_API_KEY }}
        run: |
          horus env freeze --publish \
            --name "Release ${{ github.ref_name }}"
```

**Setup:**
1. Generate API key: `horus auth generate-key --name "GitHub Actions"`
2. Copy key: `horus_live_abc123...`
3. Add to GitHub secrets:
   - Go to repository Settings → Secrets → Actions
   - New repository secret: `HORUS_API_KEY`
   - Paste key value
4. Push tag: `git tag v1.0.0 && git push origin v1.0.0`

**GitLab CI:**

`.gitlab-ci.yml`:
```yaml
publish:
  stage: deploy
  image: rust:latest
  before_script:
    - git clone https://github.com/softmata/horus.git /tmp/horus
    - cd /tmp/horus && ./install.sh
  script:
    - horus pkg publish --yes
  only:
    - tags
  variables:
    HORUS_API_KEY: $CI_HORUS_API_KEY
```

**Setup:**
1. Generate key: `horus auth generate-key --name "GitLab CI"`
2. Add to GitLab:
   - Settings → CI/CD → Variables
   - Key: `CI_HORUS_API_KEY`
   - Value: `horus_live_abc123...`
   - Type: Masked

**Docker:**

Dockerfile:
```dockerfile
FROM rust:1.70

# Install HORUS
RUN git clone https://github.com/softmata/horus.git /tmp/horus \
    && cd /tmp/horus && ./install.sh \
    && rm -rf /tmp/horus

# Copy project
COPY . /app
WORKDIR /app

# Build and publish
ARG HORUS_API_KEY
ENV HORUS_API_KEY=${HORUS_API_KEY}

RUN horus pkg publish --yes
```

Build:
```bash
docker build \
  --build-arg HORUS_API_KEY=$HORUS_API_KEY \
  -t my-horus-app .
```

**Jenkins:**

Jenkinsfile:
```groovy
pipeline {
    agent any

    environment {
        HORUS_API_KEY = credentials('horus-api-key')
    }

    stages {
        stage('Setup') {
            steps {
                sh 'git clone https://github.com/softmata/horus.git /tmp/horus && cd /tmp/horus && ./install.sh'
            }
        }

        stage('Build') {
            steps {
                sh 'horus build --release'
            }
        }

        stage('Publish') {
            when {
                buildingTag()
            }
            steps {
                sh 'horus pkg publish --yes'
            }
        }
    }
}
```

**Setup:**
1. Generate key: `horus auth generate-key --name "Jenkins"`
2. Jenkins monitor → Manage Jenkins → Credentials
3. Add secret text credential: `horus-api-key`

### Environment Variables

**Available Variables:**

**`HORUS_API_KEY`**
- API key for authentication
- Overrides credentials file
- Required for CI/CD

**`HORUS_REGISTRY_URL`**
- Custom registry URL
- Default: `https://marketplace.horus-registry.dev`
- For self-hosted or custom registries

**`HORUS_TOKEN`**
- OAuth token (alternative to API key)
- Not recommended for CI/CD

**Example usage:**
```bash
export HORUS_API_KEY=horus_live_abc123...
export HORUS_REGISTRY_URL=https://custom-registry.company.com

horus pkg publish
```

### Security Best Practices

**Token Security - Do's:**
- Use API keys for CI/CD (not OAuth tokens)
- Rotate keys every 90 days
- Use different keys for different environments
- Store keys in CI/CD secrets management
- Revoke unused keys immediately
- Use environment variables (not command-line flags)

**Token Security - Don'ts:**
- Never commit credentials to git
- Never share API keys between team members
- Never log API keys
- Never use same key for prod and dev
- Never hardcode keys in source code

**Credentials File Security:**

File permissions:
```bash
# Verify permissions
ls -la ~/.horus/credentials
# Should show: -rw------- (600)

# Fix if needed
chmod 600 ~/.horus/credentials
```

Backup:
```bash
# Backup credentials (encrypted)
gpg -c ~/.horus/credentials
# Creates ~/.horus/credentials.gpg

# Restore
gpg -d ~/.horus/credentials.gpg > ~/.horus/credentials
chmod 600 ~/.horus/credentials
```

**Key Rotation:**

Regular rotation schedule:
```bash
# 1. Generate new key
horus auth generate-key --name "Production 2025-Q4"

# 2. Update CI/CD secrets with the new key
# (Do this manually in your CI/CD platform)

# 3. Test new key
export HORUS_API_KEY=horus_live_new_key...
horus auth whoami

# 4. Revoke old key via registry web interface
# Visit https://marketplace.horus-registry.dev to manage keys
```

### Authentication Troubleshooting

**Authentication Failed:**

Error:
```
Error: Authentication required
  Run: horus auth login
```

Solutions:
```bash
# Check current status
horus auth whoami

# Re-authenticate
horus auth login

# Verify credentials file exists
ls -la ~/.horus/credentials
```

**Token Expired:**

Error:
```
Error: Token expired
  Please re-authenticate
```

Solutions:
```bash
# Re-login (auto-refreshes token)
horus auth login

# Or use API key instead
horus auth generate-key
export HORUS_API_KEY=horus_live_abc123...
```

**Invalid API Key:**

Error:
```
Error: Invalid API key
  Status: 401 Unauthorized
```

Causes:
- Key was revoked
- Key expired
- Typo in key value
- Wrong registry URL

Solutions:
```bash
# Verify key format
echo $HORUS_API_KEY
# Should start with: horus_live_

# Check key status via registry web interface
# Visit https://marketplace.horus-registry.dev

# Generate new key
horus auth generate-key
```

**Permission Denied:**

Error:
```
Error: Permission denied
  You don't have permission to publish to this package
```

Causes:
- Package owned by another user
- Not logged in
- Insufficient permissions

Solutions:
```bash
# Verify authentication
horus auth whoami

# Check package ownership via registry web interface
# Visit https://marketplace.horus-registry.dev

# For package ownership transfer, contact registry support
```

**GitHub OAuth Failed:**

Error:
```
Error: OAuth authorization failed
  Could not complete GitHub authentication
```

Solutions:
```bash
# Re-login
horus auth login

# Check browser popup blockers

# Verify GitHub account
curl https://api.github.com/user \
  -H "Authorization: Bearer <your-github-token>"
```

### Advanced Authentication Topics

**Self-Hosted Registry:**

Configure custom registry:
```bash
# Set registry URL
export HORUS_REGISTRY_URL=https://registry.company.internal

# Authenticate
horus auth login

# Use as normal
horus pkg publish
```

**Multiple Accounts:**

Switch between accounts:
```bash
# Save current credentials
mv ~/.horus/credentials ~/.horus/credentials.account1

# Login with second account
horus auth login

# Switch back
mv ~/.horus/credentials ~/.horus/credentials.account2
mv ~/.horus/credentials.account1 ~/.horus/credentials
```

## Publishing Packages

### Prerequisites

Before publishing:

1. **Authenticate** with the registry (see [Authentication](#authentication-for-publishing) section above):
   ```bash
   horus auth login
   ```

2. **Complete Cargo.toml** metadata:
   ```toml
   [package]
   name = "my-awesome-package"
   version = "1.0.0"
   authors = ["Your Name <you@example.com>"]
   description = "Brief description of your package"
   license = "MIT"
   repository = "https://github.com/username/my-awesome-package"

   [package.metadata.horus]
   category = "control"  # Navigation, Vision, Perception, Control, App, Manipulation, Simulation, Utilities
   keywords = ["pid", "controller", "motion"]
   ```

3. **Test your package** locally:
   ```bash
   horus run --release
   ```

### Publishing Workflow

```bash
# 1. Navigate to package directory
cd my-awesome-package

# 2. Verify everything builds
horus run --build-only --release

# 3. Publish
horus pkg publish
```

**Interactive prompts:**
```
Publishing my-awesome-package v1.0.0...

 Package metadata validated
 Build successful
 Tests passed
 Documentation generated

Package size: 245 KB (compressed)

Publish to registry? [y/N]: y

Uploading...
 Uploaded to registry

Published: my-awesome-package@1.0.0
Registry URL: https://marketplace.horus-registry.dev/packages/my-awesome-package

Others can now install with:
  horus pkg install my-awesome-package
```

### Adding Documentation and Source Links

After publishing, you'll be prompted to add optional metadata to help users discover and use your package:

#### Documentation Options

**External Documentation URL:**
Link to your hosted documentation website (e.g., GitHub Pages, ReadTheDocs, custom site):

```
Documentation
   Add documentation? (y/n): y

   Documentation options:
     1. External URL - Link to online documentation
     2. Local /docs - Bundle markdown files in a /docs folder

   Choose option (1/2/skip): 1
   Enter documentation URL: https://my-package-docs.example.com
    Documentation URL: https://my-package-docs.example.com
```

**Local Documentation (Bundled Markdown):**
Include markdown files directly in your package for built-in documentation viewing:

```
Documentation
    Found local /docs folder with markdown files
   Add documentation? (y/n): y

   Documentation options:
     1. External URL - Link to online documentation
     2. Local /docs - Bundle markdown files in a /docs folder

   [i] Your /docs folder should contain .md files organized as:
      /docs/README.md          (main documentation)
      /docs/getting-started.md (guides)
      /docs/api.md             (API reference)

   Choose option (1/2/skip): 2
    Will bundle local /docs folder with package
```

**Local Docs Structure:**
```
my-package/
── docs/
   ── README.md           # Main documentation page
   ── getting-started.md  # Installation and setup guide
   ── api.md              # API reference
   ── examples.md         # Usage examples
── src/
   ── lib.rs
── Cargo.toml
```

**Benefits of Local Docs:**
- Users can view docs directly from the registry
- Works offline
- Version-specific documentation
- Automatic rendering with syntax highlighting
- No external hosting required

#### Source Repository

Link to your GitHub, GitLab, or other repository:

```
Source Repository
    Auto-detected: https://github.com/username/my-package
   Add source repository? (y/n): y
   Use detected URL? (y/n): y
    Source repository: https://github.com/username/my-package
```

**Manual Entry:**
If auto-detection doesn't work or you want to use a different URL:

```
Source Repository
   Add source repository? (y/n): y

   [i] Enter the URL where your code is hosted:
      • GitHub: https://github.com/username/repo
      • GitLab: https://gitlab.com/username/repo
      • Other: Any public repository URL

   Enter source repository URL: https://gitlab.com/robotics/my-package
    Source repository: https://gitlab.com/robotics/my-package
```

#### Complete Publishing Example

```bash
$ cd my-sensor-package
$ horus pkg publish

Publishing my-sensor-package v1.0.0...
 Uploaded to registry

Published: my-sensor-package@1.0.0
   View at: https://marketplace.horus-registry.dev/packages/my-sensor-package

Package Metadata (optional)
   Help users discover and use your package by adding:

Documentation
    Found local /docs folder with markdown files
   Add documentation? (y/n): y

   Documentation options:
     1. External URL - Link to online documentation
     2. Local /docs - Bundle markdown files in a /docs folder

   [i] Your /docs folder should contain .md files organized as:
      /docs/README.md          (main documentation)
      /docs/getting-started.md (guides)
      /docs/api.md             (API reference)

   Choose option (1/2/skip): 2
    Will bundle local /docs folder with package

Source Repository
    Auto-detected: https://github.com/robotics-lab/my-sensor-package
   Add source repository? (y/n): y
   Use detected URL? (y/n): y
    Source repository: https://github.com/robotics-lab/my-sensor-package

 Updating package metadata...
Package metadata updated!
```

#### How Users See Your Links

On the registry, your package will display:

```
┌─────────────────────────────────────────┐
│  my-sensor-package      v1.0.0          │
│                                         │
│  High-performance sensor fusion         │
│                                         │
│  [View Details] [Docs] [Source]         │
│                                         │
│         Markdown Viewer  GitHub Repo    │
└─────────────────────────────────────────┘
```

- **Docs Button**: Only appears if you added documentation
  - External URL: Opens in new tab
  - Local docs: Opens built-in markdown viewer
- **Source Button**: Only appears if you added source URL
  - Opens repository in new tab

### Version Management

**Semantic Versioning:**
- `1.0.0` - Major.Minor.Patch
- `1.0.0`  `1.0.1` - Patch: Bug fixes only
- `1.0.0`  `1.1.0` - Minor: New features (backward compatible)
- `1.0.0`  `2.0.0` - Major: Breaking changes

**Publishing new version:**
```bash
# 1. Update version in Cargo.toml
[package]
version = "1.1.0"

# 2. Publish
horus pkg publish
```

**Version constraints in dependencies:**
```toml
[dependencies]
pid-controller = "1.2.0"       # Exact version
motion-planner = "^2.0"        # Compatible (2.x.x, not 3.0.0)
sensor-drivers = "~1.5.0"      # Patch updates (1.5.x)
```

## Dependency Management

### Automatic Resolution

HORUS automatically resolves and installs dependencies:

```bash
horus pkg install robot-controller
```

**Output:**
```
Resolving dependencies...
  robot-controller@1.0.0
  ── motion-planner@2.0.1
     ── pathfinding-utils@1.2.0
  ── pid-controller@1.2.0
      ── control-utils@1.0.0

Installing 5 packages...
 All dependencies installed
```

### Specifying Dependencies

In your `Cargo.toml`:

```toml
[dependencies]
horus = "0.1"
pid-controller = { version = "1.2", registry = "horus" }
motion-planner = "2.0"

# Optional dependencies
[dependencies]
advanced-planning = { version = "3.0", optional = true }

[features]
planning = ["advanced-planning"]
```

## Package Structure

### Minimal Package

```
my-package/
── Cargo.toml          # Package metadata
── src/
   ── lib.rs          # Library entry point
   ── nodes/
       ── my_node.rs  # Your node implementation
── examples/
   ── demo.rs         # Usage example
── README.md           # Documentation
```

### Library Package (`lib.rs`)

```rust
// src/lib.rs
pub mod nodes;
pub mod messages;
pub mod utils;

// Re-export commonly used items
pub use nodes::MyControllerNode;
pub use messages::MyMessage;
```

### Node Implementation

```rust
// src/nodes/my_node.rs
use horus::prelude::*;

pub struct MyControllerNode {
    pub input: Hub<f64>,
    pub output: Hub<f64>,
    gain: f64,
}

impl MyControllerNode {
    pub fn new(gain: f64) -> Self {
        Self {
            input: Hub::new("input").expect("Failed to create input hub"),
            output: Hub::new("output").expect("Failed to create output hub"),
            gain,
        }
    }
}

impl Node for MyControllerNode {
    fn name(&self) -> &'static str {
        "MyController"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(value) = self.input.recv(&mut ctx) {
            let result = value * self.gain;
            self.output.send(result, &mut ctx).ok();
        }
    }
}
```

### Example Usage

```rust
// examples/demo.rs
use my_package::MyControllerNode;
use horus::prelude::*;

fn main() {
    let mut scheduler = Scheduler::new();

    let controller = MyControllerNode::new(2.5);
    scheduler.add(Box::new(controller), 5, Some(true));

    scheduler.run().expect("Scheduler failed");
}
```

**Test the example:**
```bash
horus run examples/demo.rs --release
```

## Best Practices

### Package Design

**Single Responsibility:**
```bash
# Good: Focused packages
pid-controller          # Just PID control
motion-planner          # Just path planning
sensor-fusion           # Just sensor fusion

# Bad: Kitchen sink package
robotics-everything     # Too broad, hard to maintain
```

**Clear Interfaces:**
```rust
// Good: Simple, clear API
pub struct PIDController {
    pub fn new(kp: f64, ki: f64, kd: f64) -> Self { ... }
    pub fn update(&mut self, error: f64) -> f64 { ... }
}

// Bad: Complex, unclear API
pub struct Controller {
    pub fn do_stuff(&mut self, x: f64, y: Option<f64>, z: &str) -> Result<Vec<f64>, Box<dyn Error>> { ... }
}
```

### Documentation

**Include comprehensive README:**
```markdown
# PID Controller

Production-ready PID controller for HORUS robotics framework.

## Features
- Anti-windup protection
- Derivative filtering
- Output clamping

## Installation
```bash
horus pkg install pid-controller
```

## Usage
```rust
use pid_controller::PIDController;

let mut pid = PIDController::new(1.0, 0.1, 0.01);
let output = pid.update(error);
```

## Examples
See `examples/` directory for complete examples.

## License
MIT
```

### Testing

**Always test before publishing:**
```bash
# Run tests
horus test

# Run examples
horus run examples/demo.rs --release

# Build in release mode
horus run --build-only --release
```

### Versioning Strategy

**Semantic Versioning:**
- `0.x.x` - Development (expect breaking changes)
- `1.0.0` - First stable release
- `1.x.x` - Stable with backward compatibility
- `2.0.0` - Major rewrite or breaking changes

**Changelog:**
```markdown
# Changelog

## [1.2.0] - 2025-10-09
### Added
- Anti-windup protection
- Configurable output limits

### Fixed
- Derivative kick on setpoint change

## [1.1.0] - 2025-09-15
### Added
- Derivative filtering

## [1.0.0] - 2025-08-01
- Initial stable release
```

## Common Workflows

### Creating a Package Library

```bash
# 1. Create new project as library
horus new my-sensor-lib --rust

# 2. Update Cargo.toml
[package]
name = "my-sensor-lib"
version = "0.1.6"

[lib]
name = "my_sensor_lib"
path = "src/lib.rs"

# 3. Implement in src/lib.rs
pub mod drivers;
pub mod calibration;

# 4. Add examples
mkdir examples
# Create examples/demo.rs

# 5. Test
horus run examples/demo.rs

# 6. Publish
horus auth login
horus pkg publish
```

### Using Multiple Packages

```bash
# Install packages
horus pkg install pid-controller
horus pkg install motion-planner
horus pkg install sensor-fusion

# Use in your project
```

```rust
use pid_controller::PIDController;
use motion_planner::AStarPlanner;
use sensor_fusion::KalmanFilter;
use horus::prelude::*;

fn main() {
    let mut scheduler = Scheduler::new();

    // Combine multiple packages
    let pid = PIDController::new(1.0, 0.1, 0.01);
    let planner = AStarPlanner::new();
    let filter = KalmanFilter::new();

    // Add nodes...
}
```

### Updating Dependencies

```bash
# Update specific package to newer version
horus pkg install pid-controller -v 1.3.0

# Check available versions on registry
horus pkg list pid-controller
```

## Troubleshooting

### Package Not Found

**Error:**
```
Error: Package 'nonexistent-package' not found in registry
```

**Solutions:**
```bash
# Check spelling
horus pkg list nonexistent

# Search registry for correct package name
horus pkg list correct-package
```

### Version Conflict

**Error:**
```
Error: Version conflict
  robot-controller requires motion-planner ^2.0
  sensor-fusion requires motion-planner ^1.5
```

**Solutions:**
```bash
# Option 1: Update conflicting package
horus pkg install sensor-fusion -v 2.0.0  # Install compatible version

# Option 2: Pin version manually
# Edit Cargo.toml:
[dependencies]
motion-planner = "2.0"  # Force version 2.0
```

### Build Failures

**Error:**
```
Error: Failed to build package 'my-package'
```

**Solutions:**
```bash
# Clean and rebuild
horus pkg remove my-package
horus pkg install my-package

# Check dependencies via registry web interface
# Visit https://marketplace.horus-registry.dev

# Install dependencies manually if needed
horus pkg install dependency-name
```

### Authentication Required

**Error:**
```
Error: Authentication required to publish packages
Run: horus auth login
```

**Solution:**
```bash
horus auth login
# Opens browser for GitHub OAuth
```

### Registry Unavailable

**Error:**
```
Error: Failed to connect to registry
```

**Solutions:**
```bash
# Check internet connection
ping marketplace.horus-registry.dev

# Try again later (registry might be down)

# Use cached packages if available
ls ~/.horus/cache/
```

## Registry API

### Direct API Access

You can interact with the registry programmatically:

**Search packages:**
```bash
curl https://marketplace.horus-registry.dev/api/packages?q=sensor
```

**Get package info:**
```bash
curl https://marketplace.horus-registry.dev/api/packages/pid-controller
```

**Download package:**
```bash
curl -o pkg.tar.gz https://marketplace.horus-registry.dev/api/packages/pid-controller/1.2.0/download
```

## Next Steps

- **[Environment Management](/package-management/environment-management)** - Freeze and restore package sets
- **[CLI Reference](/development/cli-reference)** - Complete command documentation
