---
title: EncoderNode
description: Quadrature encoder reading for position and velocity measurement
---

# EncoderNode

Quadrature encoder node for reading rotary encoders on motors and wheels. Provides position, velocity, and direction information for closed-loop control and odometry.

## Source Code

- [EncoderNode Implementation](https://github.com/softmata/horus/tree/main/horus_library/nodes/encoder)
- [Encoder Sensor Messages](https://github.com/softmata/horus/blob/main/horus_library/messages/sensor.rs)

## Features

- Quadrature encoder support (AB phase via GPIO)
- Position counting (64-bit)
- Velocity calculation
- Direction detection
- Configurable resolution, wheel radius, and gear ratio
- Hardware GPIO backend with simulation fallback
- Builder pattern with hybrid processor support

## Quick Start

```rust
use horus_library::nodes::encoder::EncoderNode;
use horus::prelude::*;
use horus::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut scheduler = Scheduler::new();

    // Create encoder node
    let mut encoder = EncoderNode::new()?;

    // Configure encoder (resolution, wheel_radius, gear_ratio)
    encoder.set_encoder_config(4096.0, 0.05, 1.0);

    // Configure GPIO pins for quadrature encoder (pin A, pin B)
    encoder.set_gpio_pins(17, 27);

    scheduler.add(Box::new(encoder), 50, Some(true));
    scheduler.run()?;
    Ok(())
}

// Subscribe to odometry in another node:
let odom_hub = Hub::<Odometry>::new("odom")?;
if let Some(odom) = odom_hub.recv(&mut ctx) {
    println!("Position: ({:.2}, {:.2}), Heading: {:.2}deg",
             odom.pose.x, odom.pose.y, odom.pose.theta.to_degrees());
}
```

**Publishes to:** `odom` topic with position, velocity, and heading data.

**Requires:** GPIO hardware and the `gpio-hardware` feature.

### Enabling Features

There are three ways to enable the required `gpio-hardware` feature:

**Option 1: Automatic detection (recommended)**

When you use `horus run`, HORUS automatically detects that you're using `EncoderNode` and enables the feature:

```bash
horus run main.rs
# Output: Auto-detected hardware nodes (features: gpio-hardware)
```

**Option 2: Explicit in horus.yaml**

Add the feature to your `horus.yaml` dependencies:

```yaml
dependencies:
  - name: horus
    features:
      - gpio-hardware
```

**Option 3: Manual Cargo.toml (for cargo projects)**

If using `cargo` directly:

```toml
[dependencies]
horus_library = { version = "0.1", features = ["gpio-hardware"] }
```

## Configuration

### Construction

```rust
use horus_library::nodes::encoder::EncoderNode;

// Create with default topic "odom"
let mut encoder = EncoderNode::new()?;

// Create with custom topic
let mut encoder = EncoderNode::new_with_topic("wheel_encoder")?;
```

### Configuration Methods

```rust
// Set encoder configuration
encoder.set_encoder_config(
    1024.0,  // encoder_resolution (PPR)
    0.05,    // wheel_radius (meters)
    1.0      // gear_ratio
);

// Set coordinate frame IDs
encoder.set_frame_ids("odom", "base_link");

// Reset encoder position and distance
encoder.reset();

// Set simulation velocity (for testing without hardware)
encoder.set_simulation_velocity(
    0.5,   // linear velocity (m/s)
    0.1    // angular velocity (rad/s)
);
```

### State Query Methods

```rust
// Get current velocity (m/s)
let velocity = encoder.get_velocity();

// Get total distance traveled (meters)
let distance = encoder.get_total_distance();
```

## Configuration Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `encoder_resolution` | `f64` | `1024.0` | Pulses per revolution (PPR) |
| `wheel_radius` | `f64` | `0.1` | Wheel radius in meters |
| `gear_ratio` | `f64` | `1.0` | Gear ratio (motor rotations / wheel rotations) |
| `frame_id` | `String` | `"odom"` | Reference frame for odometry data |
| `child_frame_id` | `String` | `"base_link"` | Child frame identifier |

### Encoder Resolution

Common encoder resolutions:
- **Low resolution**: 48-128 PPR (suitable for low-speed applications)
- **Medium resolution**: 256-1024 PPR (general purpose robotics)
- **High resolution**: 2048-4096 PPR (precision positioning)

## Usage Patterns

### Basic Motor Feedback

```rust
use horus_library::nodes::encoder::EncoderNode;
use horus::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut scheduler = Scheduler::new();

    // Create encoder node for motor feedback
    let mut encoder = EncoderNode::new_with_topic("motor_encoder")?;

    // Configure for a 1024 PPR encoder on 6cm wheel
    encoder.set_encoder_config(
        1024.0,  // 1024 pulses per revolution
        0.06,    // 6cm wheel radius
        1.0      // direct drive (no gearing)
    );

    encoder.set_frame_ids("odom", "base_link");

    scheduler.add(Box::new(encoder), 50, Some(true));
    scheduler.run()?;

    Ok(())
}
```

### Wheel Odometry for Mobile Robot

```rust
use horus_library::nodes::encoder::EncoderNode;
use horus::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut scheduler = Scheduler::new();

    // Left wheel encoder
    let mut left_encoder = EncoderNode::new_with_topic("left_wheel_odom")?;
    left_encoder.set_encoder_config(
        2048.0,  // High-resolution encoder
        0.075,   // 7.5cm wheel radius
        1.0      // Direct drive
    );
    left_encoder.set_frame_ids("odom", "left_wheel");

    // Right wheel encoder
    let mut right_encoder = EncoderNode::new_with_topic("right_wheel_odom")?;
    right_encoder.set_encoder_config(
        2048.0,  // High-resolution encoder
        0.075,   // 7.5cm wheel radius
        1.0      // Direct drive
    );
    right_encoder.set_frame_ids("odom", "right_wheel");

    scheduler.add(Box::new(left_encoder), 50, Some(true));
    scheduler.add(Box::new(right_encoder), 50, Some(true));
    scheduler.run()?;

    Ok(())
}
```

### Geared Motor System

```rust
// Encoder on motor shaft with 10:1 gearbox
let mut encoder = EncoderNode::new_with_topic("geared_motor")?;

encoder.set_encoder_config(
    512.0,   // 512 PPR encoder on motor shaft
    0.05,    // 5cm output wheel
    10.0     // 10:1 gear reduction (motor spins 10x faster)
);
```

### Encoder with PID Control

```rust
use horus_library::nodes::{EncoderNode, PidControllerNode};
use horus::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut scheduler = Scheduler::new();

    // Encoder provides feedback
    let mut encoder = EncoderNode::new_with_topic("encoder.velocity")?;
    encoder.set_encoder_config(1024.0, 0.05, 1.0);

    // PID controller uses encoder feedback
    let mut pid = PidControllerNode::new_with_topics(
        "target.velocity",
        "encoder.velocity",  // Subscribe to encoder output
        "motor.command",
        "pid_config"
    )?;
    pid.set_gains(1.5, 0.2, 0.05);

    scheduler.add(Box::new(encoder), 50, Some(true));
    scheduler.add(Box::new(pid), 50, Some(true));
    scheduler.run()?;

    Ok(())
}
```

## Message Types

### Odometry

```rust
pub struct Odometry {
    pub pose: Pose2D,              // Current pose estimate
    pub twist: Twist,              // Current velocity estimate
    pub pose_covariance: [f64; 36],   // 6x6 pose covariance matrix
    pub twist_covariance: [f64; 36],  // 6x6 twist covariance matrix
    pub frame_id: [u8; 32],        // Reference frame ("odom")
    pub child_frame_id: [u8; 32],  // Child frame ("base_link")
    pub timestamp: u64,            // Nanoseconds since epoch
}
```

### Pose2D

```rust
pub struct Pose2D {
    pub x: f64,        // X position in meters
    pub y: f64,        // Y position in meters
    pub theta: f64,    // Orientation in radians
}
```

### Twist

```rust
pub struct Twist {
    pub linear: [f64; 3],   // [x, y, z] linear velocity (m/s)
    pub angular: [f64; 3],  // [roll, pitch, yaw] angular velocity (rad/s)
}
```

## Encoder Types

### Quadrature Encoders

Quadrature encoders provide two channels (A and B) that are 90 degrees out of phase:

- **Direction detection**: By comparing phase relationship of A and B channels
- **Higher resolution**: 4x multiplication (count on rising and falling edges of both channels)
- **Noise immunity**: Differential signaling reduces electrical noise

**Effective Resolution**:
```
Effective PPR = Nominal PPR x 4 (with quadrature decoding)
Example: 256 PPR encoder = 1024 counts per revolution
```

### Single Channel Encoders

Single channel encoders provide only one pulse train:

- **Direction**: Requires separate direction signal
- **Resolution**: Count only rising edges (or both edges for 2x)
- **Simpler hardware**: Lower cost, fewer pins

## Velocity Calculation

The encoder node calculates velocity using the finite difference method:

```
velocity = (current_position - last_position) / dt
```

### Distance Conversion

```
distance = (pulse_count / encoder_resolution) x (2 x PI x wheel_radius) / gear_ratio
```

## Troubleshooting

### Issue: Missed Counts

**Symptoms**: Velocity readings lower than expected, distance less than actual

**Causes**:
- Sample rate too low for encoder speed
- Electrical noise on encoder signals
- Loose encoder connections

**Solutions**:
- Increase sample rate (decrease tick interval)
- Add hardware filtering (pull-up resistors, shielded cables)
- Check encoder wiring and connections

### Issue: Incorrect Direction

**Symptoms**: Encoder counts backward when motor goes forward

**Causes**: Encoder wiring reversed, A/B channels swapped

**Solutions**:
- Swap A and B encoder channels in wiring
- Or invert direction in software

### Issue: Noisy Velocity Readings

**Symptoms**: Velocity fluctuates rapidly at constant speed

**Causes**: Low encoder resolution, quantization error at low speeds

**Solutions**:
- Use higher resolution encoder
- Implement velocity filtering
- Ensure consistent sample timing

### Issue: Distance Drifts Over Time

**Symptoms**: Cumulative distance error

**Causes**: Encoder slippage, wheel slippage, false counts from vibration

**Solutions**:
- Periodically reset encoder at known positions
- Use sensor fusion with IMU
- Improve mechanical coupling

## Performance Considerations

### CPU Usage

Minimal CPU usage per encoder:
- Position read: ~1-5 microseconds
- Velocity calculation: ~1-2 microseconds
- Message publishing: ~10-50 microseconds

**Total per tick**: ~15-60 microseconds per encoder

### Recommended Tick Rates

| Application | Tick Rate | Notes |
|-------------|-----------|-------|
| Wheel odometry | 50-100 Hz | Balance accuracy and CPU usage |
| Velocity feedback | 100-500 Hz | Higher rate for responsive control |
| Position control | 100-200 Hz | Moderate rate for stable control |
| High-speed motors | 500-1000 Hz | Fast motors need fast feedback |

## Calibration

### Encoder Resolution Calibration

1. Mark a reference point on the wheel
2. Rotate exactly one revolution
3. Count pulses received
4. Compare to nominal specification

### Wheel Radius Calibration

1. Mark starting position
2. Drive robot a known distance (e.g., 10 meters)
3. Read encoder distance
4. Calculate actual radius:

```
actual_radius = (measured_distance / 10.0) x nominal_radius
```

### Gear Ratio Calibration

1. Count motor shaft rotations for one wheel rotation
2. Calculate gear ratio: `gear_ratio = motor_rotations / wheel_rotations`

## See Also

- [OdometryNode](./odometry) - Wheel odometry
- [PidControllerNode](./pid-controller) - Closed-loop control
- [DifferentialDriveNode](./differential-drive) - Drive control
- [StepperMotorNode](./stepper-motor) - With position feedback
