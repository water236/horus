---
title: LidarNode
description: 2D/3D LiDAR laser rangefinder for mapping and obstacle detection
---

# LidarNode

LiDAR (Light Detection and Ranging) node for 2D and 3D laser rangefinding. Supports RPLidar, YDLIDAR, Hokuyo, SICK, and Velodyne sensors for SLAM, navigation, and obstacle detection.

## Source Code

- [LidarNode Implementation](https://github.com/softmata/horus/tree/main/horus_library/nodes/lidar)
- [Perception Messages](https://github.com/softmata/horus/blob/main/horus_library/messages/perception.rs)

## Features

- RPLidar A1/A2/A3, YDLIDAR X2/X4
- Hokuyo URG series, SICK TiM/LMS
- Velodyne (3D LiDAR)
- 360° scanning
- Configurable scan rate (5-20 Hz)
- Point cloud output
- Obstacle detection
- Hardware fallback to simulation

## Quick Start

```rust
use horus_library::nodes::{LidarNode, LidarBackend};
use horus::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut scheduler = Scheduler::new();

    // Option 1: Simulation mode (no hardware needed)
    let lidar = LidarNode::new()?;

    // Option 2: With real LiDAR hardware
    let mut lidar = LidarNode::new_with_backend("scan", LidarBackend::RpLidar)?;
    lidar.set_serial_port("/dev/ttyUSB0");
    lidar.set_scan_frequency(10.0);     // 10 Hz
    lidar.set_range_limits(0.15, 12.0); // 15cm to 12m

    scheduler.add(Box::new(lidar), 50, Some(true));
    scheduler.run()?;
    Ok(())
}
```

**Publishes to:** `scan` topic with 360-degree laser scan data.

**Requires:** Serial port access and the `rplidar` feature for hardware LiDAR support.

### Enabling Features

There are three ways to enable the required `rplidar` feature:

**Option 1: Automatic detection (recommended)**

When you use `horus run`, HORUS automatically detects that you're using `LidarNode` and enables the feature:

```bash
horus run main.rs
# Output: Auto-detected hardware nodes (features: rplidar)
```

**Option 2: Explicit in horus.yaml**

Add the feature to your `horus.yaml` dependencies:

```yaml
dependencies:
  - name: horus
    features:
      - rplidar
```

**Option 3: Manual Cargo.toml (for cargo projects)**

If using `cargo` directly:

```toml
[dependencies]
horus_library = { version = "0.1", features = ["rplidar"] }
```

## Supported LiDAR Models

### RPLidar Series

| Model | Range | Scan Rate | Angular Resolution | Notes |
|-------|-------|-----------|-------------------|-------|
| **RPLidar A1** | 0.15-12m | 5.5-10 Hz | 1 degree | Budget-friendly, widely used |
| **RPLidar A2** | 0.15-18m | 5-15 Hz | 0.9 degrees | Better range and speed |
| **RPLidar A3** | 0.15-25m | 5-20 Hz | 0.225-0.45 degrees | High performance |
| **RPLidar S1** | 0.15-40m | 10 Hz | 0.39 degrees | Outdoor capable |

### YDLIDAR Series

| Model | Range | Scan Rate | Angular Resolution | Notes |
|-------|-------|-----------|-------------------|-------|
| **YDLIDAR X4** | 0.12-10m | 7 Hz | 1 degree | Compact design |
| **YDLIDAR X2/X2L** | 0.12-8m | 8 Hz | 1 degree | Ultra-compact |
| **YDLIDAR G4** | 0.12-16m | 9 Hz | 0.48 degrees | High precision |
| **YDLIDAR TG15** | 0.05-30m | 10 Hz | 0.13 degrees | Time-of-flight |

### Other Supported Models

| Model | Range | Scan Rate | Notes |
|-------|-------|-----------|-------|
| **Hokuyo UTM-30LX** | 0.1-30m | 40 Hz | Industrial grade |
| **Hokuyo URG-04LX** | 0.02-5.6m | 10 Hz | Short-range precision |
| **SICK TiM/LMS** | Various | Various | Industrial automation |

## Configuration

### Construction

```rust
use horus_library::nodes::lidar::LidarNode;

// Create with default topic "scan"
let mut lidar = LidarNode::new()?;

// Create with custom topic name
let mut lidar = LidarNode::new_with_topic("front_lidar")?;

// Create with specific backend
let mut lidar = LidarNode::new_with_backend("scan", LidarBackend::RplidarA2)?;
```

### Configuration Methods

```rust
// Set LiDAR backend
lidar.set_backend(LidarBackend::RplidarA2);

// Set serial port for hardware LiDAR
lidar.set_serial_port("/dev/ttyUSB0");

// Set coordinate frame ID for transforms
lidar.set_frame_id("base_laser");

// Set scan frequency (Hz)
lidar.set_scan_frequency(15.0);  // 15 Hz scan rate

// Set range limits (min, max in meters)
lidar.set_range_limits(0.15, 12.0);  // 15cm - 12m range

// Set angular resolution (radians)
lidar.set_angle_increment(std::f32::consts::PI / 360.0);  // 0.5 degrees

// Get actual scan rate (diagnostics)
let actual_rate = lidar.get_actual_scan_rate();
eprintln!("Actual scan rate: {} Hz", actual_rate);
```

## Configuration Parameters

| Parameter | Type | Default | Range | Description |
|-----------|------|---------|-------|-------------|
| `frame_id` | `String` | `"laser_frame"` | - | Coordinate frame identifier for TF transforms |
| `scan_frequency` | `f32` | `10.0` | `0.1-100.0` Hz | Target scan rate in scans per second |
| `min_range` | `f32` | `0.1` | `>=0.0` m | Minimum valid range measurement |
| `max_range` | `f32` | `30.0` | `>min_range` m | Maximum valid range measurement |
| `angle_increment` | `f32` | `π/180` | `0.001-0.1` rad | Angular resolution (default: 1 degree) |

## Topics

### Publishers

| Topic | Type | Description |
|-------|------|-------------|
| `scan` | `LaserScan` | Laser scan data with range measurements and metadata |

## Usage Patterns

### Basic Obstacle Detection

```rust
use horus_library::nodes::lidar::LidarNode;
use horus::prelude::*;
use horus::prelude::*;

/// Custom node that detects obstacles from LiDAR scans
struct ObstacleDetector {
    scan_sub: Hub<LaserScan>,
    warning_distance: f32,
}

impl ObstacleDetector {
    fn new() -> horus_core::error::HorusResult<Self> {
        Ok(Self {
            scan_sub: Hub::new("scan")?,
            warning_distance: 0.5, // meters
        })
    }
}

impl Node for ObstacleDetector {
    fn name(&self) -> &'static str {
        "ObstacleDetector"
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        if let Some(scan) = self.scan_sub.recv(&mut ctx) {
            // Find closest obstacle
            if let Some(min_dist) = scan.min_range() {
                if min_dist < self.warning_distance {
                    if let Some(ctx) = ctx {
                        ctx.log_warning(&format!("Obstacle at {:.2} meters!", min_dist));
                    }
                }
            }
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut scheduler = Scheduler::new();

    // Create LiDAR node
    let mut lidar = LidarNode::new()?;
    lidar.set_scan_frequency(10.0);
    lidar.set_range_limits(0.1, 30.0);

    // Create obstacle detector
    let detector = ObstacleDetector::new()?;

    scheduler.add(Box::new(lidar), 50, Some(true));
    scheduler.add(Box::new(detector), 51, Some(true));
    scheduler.run()?;

    Ok(())
}
```

### Multi-LiDAR Setup (Front and Rear)

```rust
use horus_library::nodes::lidar::LidarNode;
use horus::prelude::*;
use horus::prelude::*;

/// Monitors multiple LiDAR sensors
struct MultiLidarMonitor {
    front_sub: Hub<LaserScan>,
    rear_sub: Hub<LaserScan>,
}

impl MultiLidarMonitor {
    fn new() -> horus_core::error::HorusResult<Self> {
        Ok(Self {
            front_sub: Hub::new("front.scan")?,
            rear_sub: Hub::new("rear.scan")?,
        })
    }
}

impl Node for MultiLidarMonitor {
    fn name(&self) -> &'static str {
        "MultiLidarMonitor"
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        // Process front scan
        if let Some(scan) = self.front_sub.recv(&mut ctx) {
            if let Some(ctx) = ctx {
                ctx.log_info(&format!("Front LiDAR: {} valid points", scan.valid_count()));
            }
        }

        // Process rear scan
        if let Some(scan) = self.rear_sub.recv(&mut ctx) {
            if let Some(ctx) = ctx {
                ctx.log_info(&format!("Rear LiDAR: {} valid points", scan.valid_count()));
            }
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut scheduler = Scheduler::new();

    // Front LiDAR
    let mut front_lidar = LidarNode::new_with_topic("front.scan")?;
    front_lidar.set_frame_id("front_laser");
    front_lidar.set_scan_frequency(10.0);
    front_lidar.set_range_limits(0.15, 12.0);

    // Rear LiDAR
    let mut rear_lidar = LidarNode::new_with_topic("rear.scan")?;
    rear_lidar.set_frame_id("rear_laser");
    rear_lidar.set_scan_frequency(10.0);
    rear_lidar.set_range_limits(0.15, 12.0);

    // Create monitor node
    let monitor = MultiLidarMonitor::new()?;

    scheduler.add(Box::new(front_lidar), 50, Some(true));
    scheduler.add(Box::new(rear_lidar), 50, Some(true));
    scheduler.add(Box::new(monitor), 51, Some(true));
    scheduler.run()?;

    Ok(())
}
```

### Collision Detection Zones

```rust
use horus::prelude::*;

fn check_collision_zones(scan: &LaserScan, num_zones: usize, danger_distance: f32) {
    let zone_angle = 2.0 * std::f32::consts::PI / num_zones as f32;

    for zone in 0..num_zones {
        let mut min_dist_in_zone = f32::MAX;
        let zone_start = zone as f32 * zone_angle;
        let zone_end = (zone + 1) as f32 * zone_angle;

        // Check all points in this zone
        for i in 0..360 {
            if !scan.is_range_valid(i) {
                continue;
            }

            let angle = scan.angle_at(i);
            if angle >= zone_start && angle < zone_end {
                min_dist_in_zone = min_dist_in_zone.min(scan.ranges[i]);
            }
        }

        // Alert if obstacle too close in this zone
        if min_dist_in_zone < danger_distance {
            eprintln!("Zone {}: COLLISION RISK at {:.2}m", zone, min_dist_in_zone);
        }
    }
}
```

## Message Types

### LaserScan

Laser scan message containing distance measurements and scan metadata:

```rust
pub struct LaserScan {
    /// Range measurements in meters (0 = invalid reading)
    pub ranges: [f32; 360],

    /// Start angle of the scan in radians
    pub angle_min: f32,

    /// End angle of the scan in radians
    pub angle_max: f32,

    /// Minimum valid range in meters
    pub range_min: f32,

    /// Maximum valid range in meters
    pub range_max: f32,

    /// Angular resolution in radians
    pub angle_increment: f32,

    /// Time between measurements in seconds
    pub time_increment: f32,

    /// Time to complete full scan in seconds
    pub scan_time: f32,

    /// Timestamp in nanoseconds since epoch
    pub timestamp: u64,
}
```

### LaserScan Helper Methods

```rust
// Get angle for a specific range index
let angle = scan.angle_at(index);

// Check if a range reading is valid
if scan.is_range_valid(index) {
    // Process valid range
}

// Count all valid range readings
let valid_count = scan.valid_count();

// Find closest obstacle
if let Some(min_dist) = scan.min_range() {
    eprintln!("Closest obstacle at {} meters", min_dist);
}
```

## Coordinate System

```
        0° (forward)
             |
             |
   270° -----+----- 90°
  (left)     |    (right)
             |
          180° (rear)
```

## Scan Parameters Explanation

### Angular Resolution (angle_increment)

The angular spacing between consecutive range measurements:

```rust
// 1 degree resolution (360 points per scan)
lidar.set_angle_increment(std::f32::consts::PI / 180.0);

// 0.5 degree resolution (720 points per scan)
lidar.set_angle_increment(std::f32::consts::PI / 360.0);
```

**Trade-offs:**
- **Higher resolution** (smaller increment): More detail, slower processing, more data
- **Lower resolution** (larger increment): Faster processing, less detail

### Range Limits

Define the valid measurement range for the sensor:

```rust
// Indoor navigation (short-range, high precision)
lidar.set_range_limits(0.1, 5.0);

// Outdoor navigation (long-range)
lidar.set_range_limits(0.2, 30.0);

// Obstacle avoidance (medium-range)
lidar.set_range_limits(0.15, 12.0);
```

### Scan Frequency

Number of complete 360-degree scans per second:

```rust
// Low frequency for mapping (5 Hz)
lidar.set_scan_frequency(5.0);

// Medium frequency for navigation (10 Hz)
lidar.set_scan_frequency(10.0);

// High frequency for dynamic obstacle avoidance (20 Hz)
lidar.set_scan_frequency(20.0);
```

## Integration with SLAM/Navigation

### GMapping SLAM Integration

```rust
use horus_library::nodes::lidar::LidarNode;
use horus::prelude::*;
use horus::prelude::*;

struct SlamProcessor {
    scan_sub: Hub<LaserScan>,
    min_valid_ratio: f32,
}

impl SlamProcessor {
    fn new() -> horus_core::error::HorusResult<Self> {
        Ok(Self {
            scan_sub: Hub::new("scan")?,
            min_valid_ratio: 0.8, // At least 80% valid points
        })
    }
}

impl Node for SlamProcessor {
    fn name(&self) -> &'static str { "SlamProcessor" }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        if let Some(scan) = self.scan_sub.recv(&mut ctx) {
            // Filter out invalid readings for better SLAM results
            let valid_ratio = scan.valid_count() as f32 / 360.0;
            if valid_ratio > self.min_valid_ratio {
                // Process scan for SLAM
                if let Some(ctx) = ctx {
                    ctx.log_debug(&format!("SLAM: processed scan with {:.0}% valid points",
                        valid_ratio * 100.0));
                }
            }
        }
    }
}
```

### Costmap Generation

```rust
use horus::prelude::*;

const GRID_SIZE: usize = 200;  // 200x200 grid
const GRID_RESOLUTION: f32 = 0.05;  // 5cm per cell

fn generate_costmap(scan: &LaserScan) -> [[u8; GRID_SIZE]; GRID_SIZE] {
    let mut costmap = [[0u8; GRID_SIZE]; GRID_SIZE];
    let center = GRID_SIZE / 2;

    for i in 0..360 {
        if !scan.is_range_valid(i) {
            continue;
        }

        let angle = scan.angle_at(i);
        let distance = scan.ranges[i];

        // Mark obstacle cell
        let x = center + (distance * angle.cos() / GRID_RESOLUTION) as usize;
        let y = center + (distance * angle.sin() / GRID_RESOLUTION) as usize;

        if x < GRID_SIZE && y < GRID_SIZE {
            costmap[y][x] = 255;  // Obstacle
        }
    }

    costmap
}
```

## Troubleshooting

### Issue: No scan data published

**Possible causes and solutions:**

1. **LiDAR not initialized**
   - Check initialization in logs
   - Ensure hardware is connected

2. **Node not added to scheduler**
   ```rust
   // Make sure node is added
   scheduler.add(Box::new(lidar), 50, Some(true));
   ```

3. **Wrong topic name**
   ```rust
   // Verify topic names match
   let lidar = LidarNode::new_with_topic("scan")?;
   let sub = Hub::<LaserScan>::new("scan")?;  // Must match
   ```

### Issue: Serial port permission denied

**Solution:**

```bash
# Add user to dialout group (Linux)
sudo usermod -a -G dialout $USER

# Set permissions on device
sudo chmod 666 /dev/ttyUSB0

# Verify device exists
ls -l /dev/ttyUSB*
```

**Permanent fix:**
```bash
# Create udev rule
sudo nano /etc/udev/rules.d/99-lidar.rules

# Add rule for RPLidar
KERNEL=="ttyUSB*", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", MODE="0666"

# Reload rules
sudo udevadm control --reload-rules
sudo udevadm trigger
```

### Issue: Inconsistent scan rate

**Solutions:**

1. **Hardware limitation**
   ```rust
   // Reduce scan frequency to match hardware capability
   lidar.set_scan_frequency(7.0);  // Lower than max
   ```

2. **Check actual scan rate**
   ```rust
   let actual_rate = lidar.get_actual_scan_rate();
   eprintln!("Target: {} Hz, Actual: {} Hz", scan_frequency, actual_rate);
   ```

### Issue: Noisy or invalid readings

**Solutions:**

1. **Adjust range limits**
   ```rust
   // Filter out noise at extremes
   lidar.set_range_limits(0.2, 10.0);  // Tighter limits
   ```

2. **Check hardware**
   - Clean LiDAR lens/window
   - Ensure stable mounting (no vibration)
   - Check for reflective surfaces
   - Verify power supply stability

### Issue: USB device disconnects

**Solutions:**

```bash
# Disable USB autosuspend (Linux)
echo -1 | sudo tee /sys/module/usbcore/parameters/autosuspend
```

- Use powered USB hub
- Use high-quality, shielded USB cable
- Keep cable length under 3 meters

## Performance Considerations

### CPU Usage

- **Scan generation**: &lt;1% CPU (synthetic data)
- **Data publishing**: ~2-5% CPU (10 Hz, 360 points)
- **Subscriber processing**: Depends on application

### Memory Usage

- **LaserScan message**: ~1.5 KB (360 floats + metadata)
- **Node state**: &lt;1 KB
- **Total per node**: ~2-3 KB

### Bandwidth

Data rate calculation:
```
Rate = scan_frequency × scan_size
     = 10 Hz × 1.5 KB
     = 15 KB/s per LiDAR
```

### Optimization Tips

1. **Reduce angular resolution for distant LiDARs**
   ```rust
   rear_lidar.set_angle_increment(2.0 * std::f32::consts::PI / 180.0);  // 2 degrees
   ```

2. **Use different scan frequencies for different purposes**
   ```rust
   navigation_lidar.set_scan_frequency(20.0);  // High frequency
   mapping_lidar.set_scan_frequency(5.0);      // Low frequency
   ```

3. **Use priority-based scheduling**
   ```rust
   // High priority for navigation-critical front LiDAR
   scheduler.add(Box::new(front_lidar), 10, Some(true));

   // Lower priority for monitoring rear LiDAR
   scheduler.add(Box::new(rear_lidar), 50, Some(true));
   ```

**Note**: RPLidar and YDLIDAR hardware support is temporarily limited due to upstream driver issues. When hardware is unavailable, the node automatically falls back to simulation mode.

## See Also

- [UltrasonicNode](./ultrasonic) - Short-range sensors
- [DepthCameraNode](./depth-camera) - 3D depth sensing
- [CollisionDetectorNode](./collision-detector) - Collision avoidance
